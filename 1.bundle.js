webpackJsonp([1],{

/***/ 33:
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./epg/graphic.js\": 39,\n\t\"./euclidfx/graphic.js\": 40,\n\t\"./output/graphic.js\": 41\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 33;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvcHJvY2Vzc29ycyBeXFwuXFwvLipcXC9ncmFwaGljXFwuanMkP2JlNGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9lcGcvZ3JhcGhpYy5qc1wiOiAzOSxcblx0XCIuL2V1Y2xpZGZ4L2dyYXBoaWMuanNcIjogNDAsXG5cdFwiLi9vdXRwdXQvZ3JhcGhpYy5qc1wiOiA0MVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xuXHRyZXR1cm4gaWQ7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDMzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL3doL3Byb2Nlc3NvcnMgXlxcLlxcLy4qXFwvZ3JhcGhpY1xcLmpzJFxuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n");

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createCanvasProcessorBaseView;\nfunction createCanvasProcessorBaseView(specs, my) {\n    var that,\n        initialiseBase = function initialiseBase() {},\n        terminateBase = function terminateBase() {},\n        getPosition2d = function getPosition2d() {\n        return { x: my.positionX, y: my.positionY };\n    },\n        getType = function getType() {\n        return my.type;\n    },\n        getID = function getID() {\n        return my.id;\n    };\n\n    my = my || {};\n    my.params = specs.data.params.byId;\n    my.store = specs.store;\n    my.type = specs.data.type;\n    my.id = specs.data.id;\n    my.positionX = specs.data.positionX;\n    my.positionY = specs.data.positionY;\n    my.colorHigh = '#cccccc';\n    my.colorMid = '#dddddd';\n    my.colorLow = '#eeeeee';\n\n    that = specs.that || {};\n\n    initialiseBase();\n\n    that.terminateBase = terminateBase;\n    that.getPosition2d = getPosition2d;\n    that.getID = getID;\n    that.getType = getType;\n    return that;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvdmlldy9jYW52YXNwcm9jZXNzb3JiYXNlLmpzP2VjMjkiXSwibmFtZXMiOlsiY3JlYXRlQ2FudmFzUHJvY2Vzc29yQmFzZVZpZXciLCJzcGVjcyIsIm15IiwidGhhdCIsImluaXRpYWxpc2VCYXNlIiwidGVybWluYXRlQmFzZSIsImdldFBvc2l0aW9uMmQiLCJ4IiwicG9zaXRpb25YIiwieSIsInBvc2l0aW9uWSIsImdldFR5cGUiLCJ0eXBlIiwiZ2V0SUQiLCJpZCIsInBhcmFtcyIsImRhdGEiLCJieUlkIiwic3RvcmUiLCJjb2xvckhpZ2giLCJjb2xvck1pZCIsImNvbG9yTG93Il0sIm1hcHBpbmdzIjoiOzs7OztrQkFBd0JBLDZCO0FBQVQsU0FBU0EsNkJBQVQsQ0FBdUNDLEtBQXZDLEVBQThDQyxFQUE5QyxFQUFrRDtBQUM3RCxRQUFJQyxJQUFKO0FBQUEsUUFFSUMsaUJBQWlCLFNBQWpCQSxjQUFpQixHQUFXLENBQzNCLENBSEw7QUFBQSxRQUtJQyxnQkFBZ0IsU0FBaEJBLGFBQWdCLEdBQVcsQ0FDMUIsQ0FOTDtBQUFBLFFBUUlDLGdCQUFnQixTQUFoQkEsYUFBZ0IsR0FBVztBQUN2QixlQUFPLEVBQUVDLEdBQUdMLEdBQUdNLFNBQVIsRUFBbUJDLEdBQUdQLEdBQUdRLFNBQXpCLEVBQVA7QUFDSCxLQVZMO0FBQUEsUUFZSUMsVUFBVSxTQUFWQSxPQUFVLEdBQVc7QUFDakIsZUFBT1QsR0FBR1UsSUFBVjtBQUNILEtBZEw7QUFBQSxRQWdCSUMsUUFBUSxTQUFSQSxLQUFRLEdBQVc7QUFDZixlQUFPWCxHQUFHWSxFQUFWO0FBQ0gsS0FsQkw7O0FBb0JBWixTQUFLQSxNQUFNLEVBQVg7QUFDQUEsT0FBR2EsTUFBSCxHQUFZZCxNQUFNZSxJQUFOLENBQVdELE1BQVgsQ0FBa0JFLElBQTlCO0FBQ0FmLE9BQUdnQixLQUFILEdBQVdqQixNQUFNaUIsS0FBakI7QUFDQWhCLE9BQUdVLElBQUgsR0FBVVgsTUFBTWUsSUFBTixDQUFXSixJQUFyQjtBQUNBVixPQUFHWSxFQUFILEdBQVFiLE1BQU1lLElBQU4sQ0FBV0YsRUFBbkI7QUFDQVosT0FBR00sU0FBSCxHQUFlUCxNQUFNZSxJQUFOLENBQVdSLFNBQTFCO0FBQ0FOLE9BQUdRLFNBQUgsR0FBZVQsTUFBTWUsSUFBTixDQUFXTixTQUExQjtBQUNBUixPQUFHaUIsU0FBSCxHQUFlLFNBQWY7QUFDQWpCLE9BQUdrQixRQUFILEdBQWMsU0FBZDtBQUNBbEIsT0FBR21CLFFBQUgsR0FBYyxTQUFkOztBQUVBbEIsV0FBT0YsTUFBTUUsSUFBTixJQUFjLEVBQXJCOztBQUVBQzs7QUFFQUQsU0FBS0UsYUFBTCxHQUFxQkEsYUFBckI7QUFDQUYsU0FBS0csYUFBTCxHQUFxQkEsYUFBckI7QUFDQUgsU0FBS1UsS0FBTCxHQUFhQSxLQUFiO0FBQ0FWLFNBQUtRLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFdBQU9SLElBQVA7QUFDSCIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc1Byb2Nlc3NvckJhc2VWaWV3KHNwZWNzLCBteSkge1xuICAgIHZhciB0aGF0LFxuXG4gICAgICAgIGluaXRpYWxpc2VCYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGVybWluYXRlQmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZ2V0UG9zaXRpb24yZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogbXkucG9zaXRpb25YLCB5OiBteS5wb3NpdGlvblkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGdldFR5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBteS50eXBlO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZ2V0SUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBteS5pZDtcbiAgICAgICAgfTtcbiAgICBcbiAgICBteSA9IG15IHx8IHt9O1xuICAgIG15LnBhcmFtcyA9IHNwZWNzLmRhdGEucGFyYW1zLmJ5SWQ7XG4gICAgbXkuc3RvcmUgPSBzcGVjcy5zdG9yZTtcbiAgICBteS50eXBlID0gc3BlY3MuZGF0YS50eXBlO1xuICAgIG15LmlkID0gc3BlY3MuZGF0YS5pZDtcbiAgICBteS5wb3NpdGlvblggPSBzcGVjcy5kYXRhLnBvc2l0aW9uWDtcbiAgICBteS5wb3NpdGlvblkgPSBzcGVjcy5kYXRhLnBvc2l0aW9uWTtcbiAgICBteS5jb2xvckhpZ2ggPSAnI2NjY2NjYyc7XG4gICAgbXkuY29sb3JNaWQgPSAnI2RkZGRkZCc7XG4gICAgbXkuY29sb3JMb3cgPSAnI2VlZWVlZSc7XG4gICAgXG4gICAgdGhhdCA9IHNwZWNzLnRoYXQgfHwge307XG5cbiAgICBpbml0aWFsaXNlQmFzZSgpO1xuICAgIFxuICAgIHRoYXQudGVybWluYXRlQmFzZSA9IHRlcm1pbmF0ZUJhc2U7XG4gICAgdGhhdC5nZXRQb3NpdGlvbjJkID0gZ2V0UG9zaXRpb24yZDtcbiAgICB0aGF0LmdldElEID0gZ2V0SUQ7XG4gICAgdGhhdC5nZXRUeXBlID0gZ2V0VHlwZTtcbiAgICByZXR1cm4gdGhhdDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy93aC92aWV3L2NhbnZhc3Byb2Nlc3NvcmJhc2UuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35\n");

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getEuclidPattern = getEuclidPattern;\nexports.rotateEuclidPattern = rotateEuclidPattern;\n/**\n * Euclidean pattern calculation by Michael Kontogiannis:\n * https://github.com/mkontogiannis/euclidean-rhythms\n * based on a Python script from disappeared website \n * http://www.atonalmicroshores.com/\n */\n\nvar cache = {};\n\nfunction getEuclidPattern(steps, pulses) {\n    pulses = Math.min(steps, pulses);\n    var cacheKey = steps + \"_\" + pulses;\n    if (!cache[cacheKey]) {\n        cache[cacheKey] = createBjorklund(steps, pulses);\n    }\n    return cache[cacheKey].slice(0);\n}\n\nfunction rotateEuclidPattern(pattern, rotation) {\n    var elementsToShift = pattern.splice(rotation);\n    return elementsToShift.concat(pattern);\n}\n\n/**\n * Create Euclidean rhythm pattern.\n * @param {Number} steps Total amount of tsteps in the pattern.\n * @param {Number} pulses Pulses to spread over the pattern.\n * @return {Array} Array of Booleans that form the pattern.\n */\nfunction createBjorklund(steps, pulses) {\n    if (pulses < 0 || steps < 0 || steps < pulses) {\n        return [];\n    }\n\n    // Create the two arrays\n    var first = new Array(pulses).fill([1]);\n    var second = new Array(steps - pulses).fill([0]);\n\n    var firstLength = first.length;\n    var minLength = Math.min(firstLength, second.length);\n\n    var loopThreshold = 0;\n    // Loop until at least one array has length gt 2 (1 for first loop)\n    while (minLength > loopThreshold) {\n\n        // Allow only loopThreshold to be zero on the first loop\n        if (loopThreshold === 0) {\n            loopThreshold = 1;\n        }\n\n        // For the minimum array loop and concat\n        for (var x = 0; x < minLength; x++) {\n            first[x] = Array.prototype.concat.call(first[x], second[x]);\n        }\n\n        // if the second was the bigger array, slice the remaining elements/arrays and update\n        if (minLength === firstLength) {\n            second = Array.prototype.slice.call(second, minLength);\n        }\n        // Otherwise update the second (smallest array) with the remainders of the first\n        // and update the first array to include onlt the extended sub-arrays\n        else {\n                second = Array.prototype.slice.call(first, minLength);\n                first = Array.prototype.slice.call(first, 0, minLength);\n            }\n        firstLength = first.length;\n        minLength = Math.min(firstLength, second.length);\n    }\n\n    // Build the final array\n    var pattern = [];\n    first.forEach(function (f) {\n        pattern = Array.prototype.concat.call(pattern, f);\n    });\n    second.forEach(function (s) {\n        pattern = Array.prototype.concat.call(pattern, s);\n    });\n\n    return pattern;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9lcGcvZXVjbGlkLmpzP2ZlMDAiXSwibmFtZXMiOlsiZ2V0RXVjbGlkUGF0dGVybiIsInJvdGF0ZUV1Y2xpZFBhdHRlcm4iLCJjYWNoZSIsInN0ZXBzIiwicHVsc2VzIiwiTWF0aCIsIm1pbiIsImNhY2hlS2V5IiwiY3JlYXRlQmpvcmtsdW5kIiwic2xpY2UiLCJwYXR0ZXJuIiwicm90YXRpb24iLCJlbGVtZW50c1RvU2hpZnQiLCJzcGxpY2UiLCJjb25jYXQiLCJmaXJzdCIsIkFycmF5IiwiZmlsbCIsInNlY29uZCIsImZpcnN0TGVuZ3RoIiwibGVuZ3RoIiwibWluTGVuZ3RoIiwibG9vcFRocmVzaG9sZCIsIngiLCJwcm90b3R5cGUiLCJjYWxsIiwiZm9yRWFjaCIsImYiLCJzIl0sIm1hcHBpbmdzIjoiOzs7OztRQVNnQkEsZ0IsR0FBQUEsZ0I7UUFTQUMsbUIsR0FBQUEsbUI7QUFsQmhCOzs7Ozs7O0FBT0EsSUFBTUMsUUFBUSxFQUFkOztBQUVPLFNBQVNGLGdCQUFULENBQTBCRyxLQUExQixFQUFpQ0MsTUFBakMsRUFBeUM7QUFDNUNBLGFBQVNDLEtBQUtDLEdBQUwsQ0FBU0gsS0FBVCxFQUFnQkMsTUFBaEIsQ0FBVDtBQUNBLFFBQU1HLFdBQWNKLEtBQWQsU0FBdUJDLE1BQTdCO0FBQ0EsUUFBSSxDQUFDRixNQUFNSyxRQUFOLENBQUwsRUFBc0I7QUFDbEJMLGNBQU1LLFFBQU4sSUFBa0JDLGdCQUFnQkwsS0FBaEIsRUFBdUJDLE1BQXZCLENBQWxCO0FBQ0g7QUFDRCxXQUFPRixNQUFNSyxRQUFOLEVBQWdCRSxLQUFoQixDQUFzQixDQUF0QixDQUFQO0FBQ0g7O0FBRU0sU0FBU1IsbUJBQVQsQ0FBNkJTLE9BQTdCLEVBQXNDQyxRQUF0QyxFQUFnRDtBQUNuRCxRQUFNQyxrQkFBa0JGLFFBQVFHLE1BQVIsQ0FBZUYsUUFBZixDQUF4QjtBQUNBLFdBQU9DLGdCQUFnQkUsTUFBaEIsQ0FBdUJKLE9BQXZCLENBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsU0FBU0YsZUFBVCxDQUF5QkwsS0FBekIsRUFBZ0NDLE1BQWhDLEVBQXdDO0FBQ3BDLFFBQUlBLFNBQVMsQ0FBVCxJQUFjRCxRQUFRLENBQXRCLElBQTJCQSxRQUFRQyxNQUF2QyxFQUErQztBQUMzQyxlQUFPLEVBQVA7QUFDSDs7QUFFRDtBQUNBLFFBQUlXLFFBQVEsSUFBSUMsS0FBSixDQUFVWixNQUFWLEVBQWtCYSxJQUFsQixDQUF1QixDQUFDLENBQUQsQ0FBdkIsQ0FBWjtBQUNBLFFBQUlDLFNBQVMsSUFBSUYsS0FBSixDQUFVYixRQUFRQyxNQUFsQixFQUEwQmEsSUFBMUIsQ0FBK0IsQ0FBQyxDQUFELENBQS9CLENBQWI7O0FBRUEsUUFBSUUsY0FBY0osTUFBTUssTUFBeEI7QUFDQSxRQUFJQyxZQUFZaEIsS0FBS0MsR0FBTCxDQUFTYSxXQUFULEVBQXNCRCxPQUFPRSxNQUE3QixDQUFoQjs7QUFFQSxRQUFJRSxnQkFBZ0IsQ0FBcEI7QUFDQTtBQUNBLFdBQU9ELFlBQVlDLGFBQW5CLEVBQWtDOztBQUU5QjtBQUNBLFlBQUlBLGtCQUFrQixDQUF0QixFQUF5QjtBQUNyQkEsNEJBQWdCLENBQWhCO0FBQ0g7O0FBRUQ7QUFDQSxhQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsU0FBcEIsRUFBK0JFLEdBQS9CLEVBQW9DO0FBQ2hDUixrQkFBTVEsQ0FBTixJQUFXUCxNQUFNUSxTQUFOLENBQWdCVixNQUFoQixDQUF1QlcsSUFBdkIsQ0FBNEJWLE1BQU1RLENBQU4sQ0FBNUIsRUFBc0NMLE9BQU9LLENBQVAsQ0FBdEMsQ0FBWDtBQUNIOztBQUVEO0FBQ0EsWUFBSUYsY0FBY0YsV0FBbEIsRUFBK0I7QUFDM0JELHFCQUFTRixNQUFNUSxTQUFOLENBQWdCZixLQUFoQixDQUFzQmdCLElBQXRCLENBQTJCUCxNQUEzQixFQUFtQ0csU0FBbkMsQ0FBVDtBQUNIO0FBQ0Q7QUFDQTtBQUpBLGFBS0s7QUFDREgseUJBQVNGLE1BQU1RLFNBQU4sQ0FBZ0JmLEtBQWhCLENBQXNCZ0IsSUFBdEIsQ0FBMkJWLEtBQTNCLEVBQWtDTSxTQUFsQyxDQUFUO0FBQ0FOLHdCQUFRQyxNQUFNUSxTQUFOLENBQWdCZixLQUFoQixDQUFzQmdCLElBQXRCLENBQTJCVixLQUEzQixFQUFrQyxDQUFsQyxFQUFxQ00sU0FBckMsQ0FBUjtBQUNIO0FBQ0RGLHNCQUFjSixNQUFNSyxNQUFwQjtBQUNBQyxvQkFBWWhCLEtBQUtDLEdBQUwsQ0FBU2EsV0FBVCxFQUFzQkQsT0FBT0UsTUFBN0IsQ0FBWjtBQUNIOztBQUVEO0FBQ0EsUUFBSVYsVUFBVSxFQUFkO0FBQ0FLLFVBQU1XLE9BQU4sQ0FBYyxhQUFLO0FBQ2ZoQixrQkFBVU0sTUFBTVEsU0FBTixDQUFnQlYsTUFBaEIsQ0FBdUJXLElBQXZCLENBQTRCZixPQUE1QixFQUFxQ2lCLENBQXJDLENBQVY7QUFDSCxLQUZEO0FBR0FULFdBQU9RLE9BQVAsQ0FBZSxhQUFLO0FBQ2hCaEIsa0JBQVVNLE1BQU1RLFNBQU4sQ0FBZ0JWLE1BQWhCLENBQXVCVyxJQUF2QixDQUE0QmYsT0FBNUIsRUFBcUNrQixDQUFyQyxDQUFWO0FBQ0gsS0FGRDs7QUFJQSxXQUFPbEIsT0FBUDtBQUNIIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFdWNsaWRlYW4gcGF0dGVybiBjYWxjdWxhdGlvbiBieSBNaWNoYWVsIEtvbnRvZ2lhbm5pczpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ta29udG9naWFubmlzL2V1Y2xpZGVhbi1yaHl0aG1zXG4gKiBiYXNlZCBvbiBhIFB5dGhvbiBzY3JpcHQgZnJvbSBkaXNhcHBlYXJlZCB3ZWJzaXRlIFxuICogaHR0cDovL3d3dy5hdG9uYWxtaWNyb3Nob3Jlcy5jb20vXG4gKi9cblxuY29uc3QgY2FjaGUgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV1Y2xpZFBhdHRlcm4oc3RlcHMsIHB1bHNlcykge1xuICAgIHB1bHNlcyA9IE1hdGgubWluKHN0ZXBzLCBwdWxzZXMpO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7c3RlcHN9XyR7cHVsc2VzfWA7XG4gICAgaWYgKCFjYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0gY3JlYXRlQmpvcmtsdW5kKHN0ZXBzLCBwdWxzZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldLnNsaWNlKDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlRXVjbGlkUGF0dGVybihwYXR0ZXJuLCByb3RhdGlvbikge1xuICAgIGNvbnN0IGVsZW1lbnRzVG9TaGlmdCA9IHBhdHRlcm4uc3BsaWNlKHJvdGF0aW9uKTtcbiAgICByZXR1cm4gZWxlbWVudHNUb1NoaWZ0LmNvbmNhdChwYXR0ZXJuKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgRXVjbGlkZWFuIHJoeXRobSBwYXR0ZXJuLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBzIFRvdGFsIGFtb3VudCBvZiB0c3RlcHMgaW4gdGhlIHBhdHRlcm4uXG4gKiBAcGFyYW0ge051bWJlcn0gcHVsc2VzIFB1bHNlcyB0byBzcHJlYWQgb3ZlciB0aGUgcGF0dGVybi5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBCb29sZWFucyB0aGF0IGZvcm0gdGhlIHBhdHRlcm4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJqb3JrbHVuZChzdGVwcywgcHVsc2VzKSB7XG4gICAgaWYgKHB1bHNlcyA8IDAgfHwgc3RlcHMgPCAwIHx8IHN0ZXBzIDwgcHVsc2VzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIFxuICAgIC8vIENyZWF0ZSB0aGUgdHdvIGFycmF5c1xuICAgIGxldCBmaXJzdCA9IG5ldyBBcnJheShwdWxzZXMpLmZpbGwoWzFdKTtcbiAgICBsZXQgc2Vjb25kID0gbmV3IEFycmF5KHN0ZXBzIC0gcHVsc2VzKS5maWxsKFswXSk7XG4gIFxuICAgIGxldCBmaXJzdExlbmd0aCA9IGZpcnN0Lmxlbmd0aDtcbiAgICBsZXQgbWluTGVuZ3RoID0gTWF0aC5taW4oZmlyc3RMZW5ndGgsIHNlY29uZC5sZW5ndGgpO1xuICBcbiAgICBsZXQgbG9vcFRocmVzaG9sZCA9IDA7XG4gICAgLy8gTG9vcCB1bnRpbCBhdCBsZWFzdCBvbmUgYXJyYXkgaGFzIGxlbmd0aCBndCAyICgxIGZvciBmaXJzdCBsb29wKVxuICAgIHdoaWxlIChtaW5MZW5ndGggPiBsb29wVGhyZXNob2xkKSB7XG5cbiAgICAgICAgLy8gQWxsb3cgb25seSBsb29wVGhyZXNob2xkIHRvIGJlIHplcm8gb24gdGhlIGZpcnN0IGxvb3BcbiAgICAgICAgaWYgKGxvb3BUaHJlc2hvbGQgPT09IDApIHtcbiAgICAgICAgICAgIGxvb3BUaHJlc2hvbGQgPSAxO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBGb3IgdGhlIG1pbmltdW0gYXJyYXkgbG9vcCBhbmQgY29uY2F0XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWluTGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGZpcnN0W3hdID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5jYWxsKGZpcnN0W3hdLCBzZWNvbmRbeF0pO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBpZiB0aGUgc2Vjb25kIHdhcyB0aGUgYmlnZ2VyIGFycmF5LCBzbGljZSB0aGUgcmVtYWluaW5nIGVsZW1lbnRzL2FycmF5cyBhbmQgdXBkYXRlXG4gICAgICAgIGlmIChtaW5MZW5ndGggPT09IGZpcnN0TGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWNvbmQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzZWNvbmQsIG1pbkxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHVwZGF0ZSB0aGUgc2Vjb25kIChzbWFsbGVzdCBhcnJheSkgd2l0aCB0aGUgcmVtYWluZGVycyBvZiB0aGUgZmlyc3RcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSB0aGUgZmlyc3QgYXJyYXkgdG8gaW5jbHVkZSBvbmx0IHRoZSBleHRlbmRlZCBzdWItYXJyYXlzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Vjb25kID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmlyc3QsIG1pbkxlbmd0aCk7XG4gICAgICAgICAgICBmaXJzdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpcnN0LCAwLCBtaW5MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0TGVuZ3RoID0gZmlyc3QubGVuZ3RoO1xuICAgICAgICBtaW5MZW5ndGggPSBNYXRoLm1pbihmaXJzdExlbmd0aCwgc2Vjb25kLmxlbmd0aCk7XG4gICAgfVxuICBcbiAgICAvLyBCdWlsZCB0aGUgZmluYWwgYXJyYXlcbiAgICBsZXQgcGF0dGVybiA9IFtdO1xuICAgIGZpcnN0LmZvckVhY2goZiA9PiB7XG4gICAgICAgIHBhdHRlcm4gPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwocGF0dGVybiwgZik7XG4gICAgfSk7XG4gICAgc2Vjb25kLmZvckVhY2gocyA9PiB7XG4gICAgICAgIHBhdHRlcm4gPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwocGF0dGVybiwgcyk7XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBwYXR0ZXJuO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3doL3Byb2Nlc3NvcnMvZXBnL2V1Y2xpZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36\n");

/***/ }),

/***/ 37:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getEuclidPattern = getEuclidPattern;\nexports.rotateEuclidPattern = rotateEuclidPattern;\n/**\n * Euclidean pattern calculation by Michael Kontogiannis:\n * https://github.com/mkontogiannis/euclidean-rhythms\n * based on a Python script from disappeared website \n * http://www.atonalmicroshores.com/\n */\n\nvar cache = {};\n\nfunction getEuclidPattern(steps, pulses) {\n    pulses = Math.min(steps, pulses);\n    var cacheKey = steps + \"_\" + pulses;\n    if (!cache[cacheKey]) {\n        cache[cacheKey] = createBjorklund(steps, pulses);\n    }\n    return cache[cacheKey].slice(0);\n}\n\nfunction rotateEuclidPattern(pattern, rotation) {\n    var elementsToShift = pattern.splice(rotation);\n    return elementsToShift.concat(pattern);\n}\n\n/**\n * Create Euclidean rhythm pattern.\n * @param {Number} steps Total amount of tsteps in the pattern.\n * @param {Number} pulses Pulses to spread over the pattern.\n * @return {Array} Array of Booleans that form the pattern.\n */\nfunction createBjorklund(steps, pulses) {\n    if (pulses < 0 || steps < 0 || steps < pulses) {\n        return [];\n    }\n\n    // Create the two arrays\n    var first = new Array(pulses).fill([1]);\n    var second = new Array(steps - pulses).fill([0]);\n\n    var firstLength = first.length;\n    var minLength = Math.min(firstLength, second.length);\n\n    var loopThreshold = 0;\n    // Loop until at least one array has length gt 2 (1 for first loop)\n    while (minLength > loopThreshold) {\n\n        // Allow only loopThreshold to be zero on the first loop\n        if (loopThreshold === 0) {\n            loopThreshold = 1;\n        }\n\n        // For the minimum array loop and concat\n        for (var x = 0; x < minLength; x++) {\n            first[x] = Array.prototype.concat.call(first[x], second[x]);\n        }\n\n        // if the second was the bigger array, slice the remaining elements/arrays and update\n        if (minLength === firstLength) {\n            second = Array.prototype.slice.call(second, minLength);\n        }\n        // Otherwise update the second (smallest array) with the remainders of the first\n        // and update the first array to include onlt the extended sub-arrays\n        else {\n                second = Array.prototype.slice.call(first, minLength);\n                first = Array.prototype.slice.call(first, 0, minLength);\n            }\n        firstLength = first.length;\n        minLength = Math.min(firstLength, second.length);\n    }\n\n    // Build the final array\n    var pattern = [];\n    first.forEach(function (f) {\n        pattern = Array.prototype.concat.call(pattern, f);\n    });\n    second.forEach(function (s) {\n        pattern = Array.prototype.concat.call(pattern, s);\n    });\n\n    return pattern;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9ldWNsaWRmeC9ldWNsaWQuanM/MDRkNSJdLCJuYW1lcyI6WyJnZXRFdWNsaWRQYXR0ZXJuIiwicm90YXRlRXVjbGlkUGF0dGVybiIsImNhY2hlIiwic3RlcHMiLCJwdWxzZXMiLCJNYXRoIiwibWluIiwiY2FjaGVLZXkiLCJjcmVhdGVCam9ya2x1bmQiLCJzbGljZSIsInBhdHRlcm4iLCJyb3RhdGlvbiIsImVsZW1lbnRzVG9TaGlmdCIsInNwbGljZSIsImNvbmNhdCIsImZpcnN0IiwiQXJyYXkiLCJmaWxsIiwic2Vjb25kIiwiZmlyc3RMZW5ndGgiLCJsZW5ndGgiLCJtaW5MZW5ndGgiLCJsb29wVGhyZXNob2xkIiwieCIsInByb3RvdHlwZSIsImNhbGwiLCJmb3JFYWNoIiwiZiIsInMiXSwibWFwcGluZ3MiOiI7Ozs7O1FBU2dCQSxnQixHQUFBQSxnQjtRQVNBQyxtQixHQUFBQSxtQjtBQWxCaEI7Ozs7Ozs7QUFPQSxJQUFNQyxRQUFRLEVBQWQ7O0FBRU8sU0FBU0YsZ0JBQVQsQ0FBMEJHLEtBQTFCLEVBQWlDQyxNQUFqQyxFQUF5QztBQUM1Q0EsYUFBU0MsS0FBS0MsR0FBTCxDQUFTSCxLQUFULEVBQWdCQyxNQUFoQixDQUFUO0FBQ0EsUUFBTUcsV0FBY0osS0FBZCxTQUF1QkMsTUFBN0I7QUFDQSxRQUFJLENBQUNGLE1BQU1LLFFBQU4sQ0FBTCxFQUFzQjtBQUNsQkwsY0FBTUssUUFBTixJQUFrQkMsZ0JBQWdCTCxLQUFoQixFQUF1QkMsTUFBdkIsQ0FBbEI7QUFDSDtBQUNELFdBQU9GLE1BQU1LLFFBQU4sRUFBZ0JFLEtBQWhCLENBQXNCLENBQXRCLENBQVA7QUFDSDs7QUFFTSxTQUFTUixtQkFBVCxDQUE2QlMsT0FBN0IsRUFBc0NDLFFBQXRDLEVBQWdEO0FBQ25ELFFBQU1DLGtCQUFrQkYsUUFBUUcsTUFBUixDQUFlRixRQUFmLENBQXhCO0FBQ0EsV0FBT0MsZ0JBQWdCRSxNQUFoQixDQUF1QkosT0FBdkIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7QUFNQSxTQUFTRixlQUFULENBQXlCTCxLQUF6QixFQUFnQ0MsTUFBaEMsRUFBd0M7QUFDcEMsUUFBSUEsU0FBUyxDQUFULElBQWNELFFBQVEsQ0FBdEIsSUFBMkJBLFFBQVFDLE1BQXZDLEVBQStDO0FBQzNDLGVBQU8sRUFBUDtBQUNIOztBQUVEO0FBQ0EsUUFBSVcsUUFBUSxJQUFJQyxLQUFKLENBQVVaLE1BQVYsRUFBa0JhLElBQWxCLENBQXVCLENBQUMsQ0FBRCxDQUF2QixDQUFaO0FBQ0EsUUFBSUMsU0FBUyxJQUFJRixLQUFKLENBQVViLFFBQVFDLE1BQWxCLEVBQTBCYSxJQUExQixDQUErQixDQUFDLENBQUQsQ0FBL0IsQ0FBYjs7QUFFQSxRQUFJRSxjQUFjSixNQUFNSyxNQUF4QjtBQUNBLFFBQUlDLFlBQVloQixLQUFLQyxHQUFMLENBQVNhLFdBQVQsRUFBc0JELE9BQU9FLE1BQTdCLENBQWhCOztBQUVBLFFBQUlFLGdCQUFnQixDQUFwQjtBQUNBO0FBQ0EsV0FBT0QsWUFBWUMsYUFBbkIsRUFBa0M7O0FBRTlCO0FBQ0EsWUFBSUEsa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3JCQSw0QkFBZ0IsQ0FBaEI7QUFDSDs7QUFFRDtBQUNBLGFBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRixTQUFwQixFQUErQkUsR0FBL0IsRUFBb0M7QUFDaENSLGtCQUFNUSxDQUFOLElBQVdQLE1BQU1RLFNBQU4sQ0FBZ0JWLE1BQWhCLENBQXVCVyxJQUF2QixDQUE0QlYsTUFBTVEsQ0FBTixDQUE1QixFQUFzQ0wsT0FBT0ssQ0FBUCxDQUF0QyxDQUFYO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJRixjQUFjRixXQUFsQixFQUErQjtBQUMzQkQscUJBQVNGLE1BQU1RLFNBQU4sQ0FBZ0JmLEtBQWhCLENBQXNCZ0IsSUFBdEIsQ0FBMkJQLE1BQTNCLEVBQW1DRyxTQUFuQyxDQUFUO0FBQ0g7QUFDRDtBQUNBO0FBSkEsYUFLSztBQUNESCx5QkFBU0YsTUFBTVEsU0FBTixDQUFnQmYsS0FBaEIsQ0FBc0JnQixJQUF0QixDQUEyQlYsS0FBM0IsRUFBa0NNLFNBQWxDLENBQVQ7QUFDQU4sd0JBQVFDLE1BQU1RLFNBQU4sQ0FBZ0JmLEtBQWhCLENBQXNCZ0IsSUFBdEIsQ0FBMkJWLEtBQTNCLEVBQWtDLENBQWxDLEVBQXFDTSxTQUFyQyxDQUFSO0FBQ0g7QUFDREYsc0JBQWNKLE1BQU1LLE1BQXBCO0FBQ0FDLG9CQUFZaEIsS0FBS0MsR0FBTCxDQUFTYSxXQUFULEVBQXNCRCxPQUFPRSxNQUE3QixDQUFaO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJVixVQUFVLEVBQWQ7QUFDQUssVUFBTVcsT0FBTixDQUFjLGFBQUs7QUFDZmhCLGtCQUFVTSxNQUFNUSxTQUFOLENBQWdCVixNQUFoQixDQUF1QlcsSUFBdkIsQ0FBNEJmLE9BQTVCLEVBQXFDaUIsQ0FBckMsQ0FBVjtBQUNILEtBRkQ7QUFHQVQsV0FBT1EsT0FBUCxDQUFlLGFBQUs7QUFDaEJoQixrQkFBVU0sTUFBTVEsU0FBTixDQUFnQlYsTUFBaEIsQ0FBdUJXLElBQXZCLENBQTRCZixPQUE1QixFQUFxQ2tCLENBQXJDLENBQVY7QUFDSCxLQUZEOztBQUlBLFdBQU9sQixPQUFQO0FBQ0giLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV1Y2xpZGVhbiBwYXR0ZXJuIGNhbGN1bGF0aW9uIGJ5IE1pY2hhZWwgS29udG9naWFubmlzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL21rb250b2dpYW5uaXMvZXVjbGlkZWFuLXJoeXRobXNcbiAqIGJhc2VkIG9uIGEgUHl0aG9uIHNjcmlwdCBmcm9tIGRpc2FwcGVhcmVkIHdlYnNpdGUgXG4gKiBodHRwOi8vd3d3LmF0b25hbG1pY3Jvc2hvcmVzLmNvbS9cbiAqL1xuXG5jb25zdCBjYWNoZSA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXVjbGlkUGF0dGVybihzdGVwcywgcHVsc2VzKSB7XG4gICAgcHVsc2VzID0gTWF0aC5taW4oc3RlcHMsIHB1bHNlcyk7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtzdGVwc31fJHtwdWxzZXN9YDtcbiAgICBpZiAoIWNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSBjcmVhdGVCam9ya2x1bmQoc3RlcHMsIHB1bHNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV0uc2xpY2UoMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVFdWNsaWRQYXR0ZXJuKHBhdHRlcm4sIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgZWxlbWVudHNUb1NoaWZ0ID0gcGF0dGVybi5zcGxpY2Uocm90YXRpb24pO1xuICAgIHJldHVybiBlbGVtZW50c1RvU2hpZnQuY29uY2F0KHBhdHRlcm4pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBFdWNsaWRlYW4gcmh5dGhtIHBhdHRlcm4uXG4gKiBAcGFyYW0ge051bWJlcn0gc3RlcHMgVG90YWwgYW1vdW50IG9mIHRzdGVwcyBpbiB0aGUgcGF0dGVybi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwdWxzZXMgUHVsc2VzIHRvIHNwcmVhZCBvdmVyIHRoZSBwYXR0ZXJuLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIEJvb2xlYW5zIHRoYXQgZm9ybSB0aGUgcGF0dGVybi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmpvcmtsdW5kKHN0ZXBzLCBwdWxzZXMpIHtcbiAgICBpZiAocHVsc2VzIDwgMCB8fCBzdGVwcyA8IDAgfHwgc3RlcHMgPCBwdWxzZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgXG4gICAgLy8gQ3JlYXRlIHRoZSB0d28gYXJyYXlzXG4gICAgbGV0IGZpcnN0ID0gbmV3IEFycmF5KHB1bHNlcykuZmlsbChbMV0pO1xuICAgIGxldCBzZWNvbmQgPSBuZXcgQXJyYXkoc3RlcHMgLSBwdWxzZXMpLmZpbGwoWzBdKTtcbiAgXG4gICAgbGV0IGZpcnN0TGVuZ3RoID0gZmlyc3QubGVuZ3RoO1xuICAgIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihmaXJzdExlbmd0aCwgc2Vjb25kLmxlbmd0aCk7XG4gIFxuICAgIGxldCBsb29wVGhyZXNob2xkID0gMDtcbiAgICAvLyBMb29wIHVudGlsIGF0IGxlYXN0IG9uZSBhcnJheSBoYXMgbGVuZ3RoIGd0IDIgKDEgZm9yIGZpcnN0IGxvb3ApXG4gICAgd2hpbGUgKG1pbkxlbmd0aCA+IGxvb3BUaHJlc2hvbGQpIHtcblxuICAgICAgICAvLyBBbGxvdyBvbmx5IGxvb3BUaHJlc2hvbGQgdG8gYmUgemVybyBvbiB0aGUgZmlyc3QgbG9vcFxuICAgICAgICBpZiAobG9vcFRocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgbG9vcFRocmVzaG9sZCA9IDE7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIEZvciB0aGUgbWluaW11bSBhcnJheSBsb29wIGFuZCBjb25jYXRcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtaW5MZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgZmlyc3RbeF0gPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoZmlyc3RbeF0sIHNlY29uZFt4XSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGlmIHRoZSBzZWNvbmQgd2FzIHRoZSBiaWdnZXIgYXJyYXksIHNsaWNlIHRoZSByZW1haW5pbmcgZWxlbWVudHMvYXJyYXlzIGFuZCB1cGRhdGVcbiAgICAgICAgaWYgKG1pbkxlbmd0aCA9PT0gZmlyc3RMZW5ndGgpIHtcbiAgICAgICAgICAgIHNlY29uZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNlY29uZCwgbWluTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgdXBkYXRlIHRoZSBzZWNvbmQgKHNtYWxsZXN0IGFycmF5KSB3aXRoIHRoZSByZW1haW5kZXJzIG9mIHRoZSBmaXJzdFxuICAgICAgICAvLyBhbmQgdXBkYXRlIHRoZSBmaXJzdCBhcnJheSB0byBpbmNsdWRlIG9ubHQgdGhlIGV4dGVuZGVkIHN1Yi1hcnJheXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWNvbmQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmaXJzdCwgbWluTGVuZ3RoKTtcbiAgICAgICAgICAgIGZpcnN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmlyc3QsIDAsIG1pbkxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RMZW5ndGggPSBmaXJzdC5sZW5ndGg7XG4gICAgICAgIG1pbkxlbmd0aCA9IE1hdGgubWluKGZpcnN0TGVuZ3RoLCBzZWNvbmQubGVuZ3RoKTtcbiAgICB9XG4gIFxuICAgIC8vIEJ1aWxkIHRoZSBmaW5hbCBhcnJheVxuICAgIGxldCBwYXR0ZXJuID0gW107XG4gICAgZmlyc3QuZm9yRWFjaChmID0+IHtcbiAgICAgICAgcGF0dGVybiA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChwYXR0ZXJuLCBmKTtcbiAgICB9KTtcbiAgICBzZWNvbmQuZm9yRWFjaChzID0+IHtcbiAgICAgICAgcGF0dGVybiA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChwYXR0ZXJuLCBzKTtcbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIHBhdHRlcm47XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9ldWNsaWRmeC9ldWNsaWQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n");

/***/ }),

/***/ 39:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createGraphic = createGraphic;\n\nvar _canvasprocessorbase = __webpack_require__(35);\n\nvar _canvasprocessorbase2 = _interopRequireDefault(_canvasprocessorbase);\n\nvar _euclid = __webpack_require__(36);\n\nvar _config = __webpack_require__(8);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Euclidean pattern animated necklace wheel drawn on canvas.\n */\nfunction createGraphic(specs, my) {\n    var that = void 0,\n        canvasDirtyCallback = specs.canvasDirtyCallback,\n        staticCanvas = void 0,\n        staticCtx = void 0,\n        necklaceCanvas = void 0,\n        necklaceCtx = void 0,\n        nameCanvas = void 0,\n        nameCtx = void 0,\n        pointerCanvas = void 0,\n        pointerCtx = void 0,\n        pointerRotation = void 0,\n        pointerRotationPrevious = 0,\n        pointerMutedRadius = 30,\n        pointerCanvasCenter = void 0,\n        radius = 110,\n        necklaceMinRadius = 50,\n        necklaceRadius = void 0,\n        centerDotFullRadius = 10,\n        centerDotRadius = void 0,\n        centerDotSize = void 0,\n        centerDotX = void 0,\n        centerDotY = void 0,\n        centerDotStartTween = void 0,\n        centerDotEndTween = void 0,\n        centerRadius = 20,\n        outConnectorY = 35,\n        selectRadius = 15,\n        dotRadius = void 0,\n        dotMaxRadius = 10,\n        dotActiveRadius = void 0,\n        zeroMarkerRadius = 3,\n        lineWidth = 2,\n        isSelected = false,\n        doublePI = Math.PI * 2,\n        dotAnimations = {},\n        isNoteActive = false,\n        necklace = [],\n        duration = 0,\n        initialise = function initialise() {\n        document.addEventListener(my.store.STATE_CHANGE, handleStateChanges);\n        canvasDirtyCallback = specs.canvasDirtyCallback;\n\n        initGraphics();\n        setTheme(specs.theme);\n        updatePosition(specs.data.positionX, specs.data.positionY);\n        redrawStaticCanvas();\n        updateDuration();\n    },\n\n\n    /**\n     * Called before this view is deleted.\n     */\n    terminate = function terminate() {\n        document.removeEventListener(my.store.STATE_CHANGE, handleStateChanges);\n        canvasDirtyCallback = null;\n    },\n        handleStateChanges = function handleStateChanges(e) {\n        switch (e.detail.action.type) {\n            case e.detail.actions.CHANGE_PARAMETER:\n                if (e.detail.action.processorID === my.id) {\n                    my.params = e.detail.state.processors.byId[my.id].params.byId;\n                    switch (e.detail.action.paramKey) {\n                        case 'steps':\n                        case 'pulses':\n                            updateDuration();\n                        // fall through\n                        case 'rotation':\n                            updateNecklace();\n                            break;\n                        case 'is_mute':\n                            updatePointer();\n                            break;\n                        case 'name':\n                            updateName();\n                            break;\n                        case 'is_triplets':\n                        case 'rate':\n                        case 'note_length':\n                            updateDuration();\n                            break;\n                    }\n                }\n                break;\n\n            case e.detail.actions.DRAG_SELECTED_PROCESSOR:\n            case e.detail.actions.DRAG_ALL_PROCESSORS:\n                var processor = e.detail.state.processors.byId[my.id];\n                updatePosition(processor.positionX, processor.positionY);\n                break;\n        }\n    },\n        initGraphics = function initGraphics() {\n        // offscreen canvas for static shapes\n        staticCanvas = document.createElement('canvas');\n        staticCanvas.height = radius * 2;\n        staticCanvas.width = radius * 2;\n        staticCtx = staticCanvas.getContext('2d');\n        staticCtx.lineWidth = lineWidth;\n\n        // offscreen canvas for dots ring and polygon\n        necklaceCanvas = document.createElement('canvas');\n        necklaceCanvas.height = radius * 2;\n        necklaceCanvas.width = radius * 2;\n        necklaceCtx = necklaceCanvas.getContext('2d');\n        necklaceCtx.lineWidth = lineWidth;\n\n        // offscreen canvas for the pointer\n        pointerCanvas = document.createElement('canvas');\n        pointerCanvas.height = radius;\n        pointerCanvas.width = centerRadius * 2;\n        pointerCtx = pointerCanvas.getContext('2d');\n        pointerCtx.lineWidth = lineWidth;\n        pointerCanvasCenter = pointerCanvas.width / 2;\n\n        // offscreen canvas for the name\n        nameCanvas = document.createElement('canvas');\n        nameCanvas.height = 40;\n        nameCanvas.width = radius * 2;\n        nameCtx = nameCanvas.getContext('2d');\n        nameCtx.font = '14px sans-serif';\n        nameCtx.textAlign = 'center';\n\n        // width and height to clear center dot \n        centerDotSize = (centerDotFullRadius + 1) * 2;\n    },\n\n\n    /**\n     * Show circle if the my.processor is selected, else hide.\n     * @param {Boolean} isSelectedView True if selected.\n     */\n    setSelected = function setSelected(isSelectedView) {\n        isSelected = isSelectedView;\n        if (typeof redrawStaticCanvas == 'function' && typeof canvasDirtyCallback == 'function') {\n            redrawStaticCanvas();\n            canvasDirtyCallback();\n        }\n    },\n        draw = function draw(position, processorEvents) {\n        showPlaybackPosition(position);\n        updateNoteAnimations();\n\n        if (processorEvents[my.id] && processorEvents[my.id].length) {\n            for (var i = 0, n = processorEvents[my.id].length; i < n; i++) {\n                var event = processorEvents[my.id][i];\n                startNoteAnimation(event.stepIndex, event.delayFromNowToNoteStart, event.delayFromNowToNoteEnd);\n            }\n        }\n    },\n\n\n    /**\n     * Show the playback position within the pattern.\n     * Indicated by the pointer's rotation.\n     * @param  {Number} position Position within pattern in ticks.\n     */\n    showPlaybackPosition = function showPlaybackPosition(position) {\n        pointerRotationPrevious = pointerRotation;\n        pointerRotation = doublePI * (position % duration / duration);\n    },\n\n\n    /**\n     * Update the current nacklace dot animations.\n     */\n    updateNoteAnimations = function updateNoteAnimations() {\n        Object.keys(dotAnimations).forEach(function (key) {\n            var obj = dotAnimations[key];\n            obj.dotRadius /= 1.1;\n            if (obj.isActive && obj.dotRadius < 1) {\n                delete dotAnimations[key];\n            }\n        });\n    },\n\n\n    /**\n     * Show animation of the pattern dot that is about to play. \n     * @param {Number} stepIndex Index of the step to play.\n     * @param {Number} noteStartDelay Delay from now until note start in ms.\n     * @param {Number} noteStopDelay Delay from now until note end in ms.\n     */\n    startNoteAnimation = function startNoteAnimation(stepIndex, noteStartDelay, noteStopDelay) {\n        // get the coordinates of the dot for this step\n        var steps = my.params.steps.value;\n\n        // retain necklace dot state in object\n        dotAnimations[stepIndex] = {\n            positionX: necklace[stepIndex].center.x,\n            positionY: necklace[stepIndex].center.y,\n            boundingBox: necklace[stepIndex].rect,\n            dotRadius: 0,\n            isActive: false\n\n            // delay start of animation\n        };setTimeout(function () {\n            var tweeningDot = dotAnimations[stepIndex];\n            tweeningDot.dotRadius = dotActiveRadius;\n            tweeningDot.isActive = true;\n        }, noteStartDelay);\n    },\n\n\n    /**\n     * Calculate the pattern's duration in milliseconds.\n     */\n    updateDuration = function updateDuration() {\n        var rate = my.params.is_triplets.value ? my.params.rate.value * (2 / 3) : my.params.rate.value,\n            stepDuration = rate * _config.PPQN;\n        duration = my.params.steps.value * stepDuration;\n    },\n\n\n    /**\n     * Update the pattern dots.\n     * If the steps, pulses or rotation properties have changed.\n     * If steps change it might invalidate the pointer.\n     */\n    updateNecklace = function updateNecklace() {\n        var steps = my.params.steps.value,\n            pulses = my.params.pulses.value,\n            rotation = my.params.rotation.value,\n            euclid = void 0,\n            rad = void 0,\n            x = void 0,\n            y = void 0;\n\n        euclid = (0, _euclid.getEuclidPattern)(steps, pulses);\n        euclid = (0, _euclid.rotateEuclidPattern)(euclid, rotation);\n\n        necklace = [];\n\n        // calculate the dot positions\n        necklaceRadius = necklaceMinRadius + Math.max(0, steps - 16) * 0.8;\n        for (var i = 0; i < steps; i++) {\n            rad = doublePI * (i / steps);\n            x = Math.sin(rad) * necklaceRadius;\n            y = Math.cos(rad) * necklaceRadius;\n            necklace.push({\n                center: {\n                    x: x,\n                    y: y\n                },\n                rect: {\n                    x: x - dotMaxRadius * 2,\n                    y: y + dotMaxRadius * 2,\n                    xAbs: 0,\n                    yAbs: 0,\n                    height: dotMaxRadius * 4,\n                    width: dotMaxRadius * 4\n                }\n            });\n        }\n\n        necklaceCtx.clearRect(0, 0, necklaceCanvas.width, necklaceCanvas.height);\n\n        updateNecklaceAbsolute();\n        updatePolygon(steps, pulses, euclid, necklace);\n        updateDots(steps, euclid, necklace);\n        updatePointer();\n        updateZeroMarker(steps, rotation);\n        updateRotatedMarker(steps, rotation);\n        redrawStaticCanvas();\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Update the coordinates of the necklace nodes relative to the main canvas.\n     */\n    updateNecklaceAbsolute = function updateNecklaceAbsolute() {\n        var rect = void 0;\n        for (var i = 0, n = necklace.length; i < n; i++) {\n            rect = necklace[i].rect;\n            rect.xAbs = my.positionX + rect.x;\n            rect.yAbs = my.positionY - rect.y;\n        }\n    },\n\n\n    /**\n     * Update pattern's position on the 2D canvas.\n     * @param  {Object} value New 2D position as object.\n     */\n    updatePosition = function updatePosition(x, y) {\n        my.positionX = x;\n        my.positionY = y;\n        centerDotX = my.positionX - centerDotFullRadius - 1;\n        centerDotY = my.positionY - centerDotFullRadius - 1;\n        updateNecklaceAbsolute();\n        redrawStaticCanvas();\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Draw polygon.\n     */\n    updatePolygon = function updatePolygon(steps, pulses, euclid, necklace) {\n        if (pulses > 1) {\n            necklaceCtx.fillStyle = my.colorLow;\n            necklaceCtx.strokeStyle = my.colorLow;\n            necklaceCtx.beginPath();\n            var isFirstPoint = true,\n                firstPoint = void 0,\n                dotCenter = void 0;\n            for (var i = 0; i < steps; i++) {\n                if (euclid[i]) {\n                    dotCenter = necklace[i].center;\n                    if (isFirstPoint) {\n                        isFirstPoint = false;\n                        firstPoint = dotCenter;\n                        necklaceCtx.moveTo(radius + firstPoint.x, radius - firstPoint.y);\n                    } else {\n                        necklaceCtx.lineTo(radius + dotCenter.x, radius - dotCenter.y);\n                    }\n                }\n            }\n            necklaceCtx.lineTo(radius + firstPoint.x, radius - firstPoint.y);\n            necklaceCtx.stroke();\n            necklaceCtx.globalAlpha = 0.6;\n            necklaceCtx.fill();\n            necklaceCtx.globalAlpha = 1.0;\n        }\n    },\n\n\n    /**\n     * Draw the necklace dots in their inactive state.\n     */\n    updateDots = function updateDots(steps, euclid, necklace) {\n        dotRadius = dotMaxRadius - 3 - Math.max(0, steps - 16) * 0.09;\n        dotActiveRadius = dotRadius * 2.5;\n\n        necklaceCtx.fillStyle = my.colorHigh;\n        necklaceCtx.strokeStyle = my.colorHigh;\n        var point = void 0;\n        for (var i = 0; i < steps; i++) {\n            point = necklace[i].center;\n            if (euclid[i]) {\n                // active dot\n                necklaceCtx.beginPath();\n                necklaceCtx.moveTo(radius + point.x + dotRadius, radius - point.y);\n                necklaceCtx.arc(radius + point.x, radius - point.y, dotRadius, 0, doublePI, true);\n                necklaceCtx.fill();\n                necklaceCtx.stroke();\n            } else {\n                // passive dot\n                necklaceCtx.beginPath();\n                necklaceCtx.moveTo(radius + point.x + dotRadius, radius - point.y);\n                necklaceCtx.arc(radius + point.x, radius - point.y, dotRadius, 0, doublePI, true);\n                necklaceCtx.stroke();\n            }\n        }\n    },\n\n\n    /**\n     * Update the pointer that connects the dots.\n     */\n    updatePointer = function updatePointer() {\n        var isMute = my.params.is_mute.value,\n            pointerRadius = isMute ? pointerMutedRadius : necklaceRadius,\n            pointerX = isMute ? 15 : 19,\n            pointerY = isMute ? 15 : 6;\n\n        pointerCtx.clearRect(0, 0, pointerCanvas.width, pointerCanvas.height);\n        pointerCtx.beginPath();\n        pointerCtx.moveTo(pointerCanvasCenter - pointerX, pointerCanvas.height - pointerY);\n        pointerCtx.lineTo(pointerCanvasCenter, pointerCanvas.height - pointerRadius);\n        pointerCtx.lineTo(pointerCanvasCenter + pointerX, pointerCanvas.height - pointerY);\n        pointerCtx.stroke();\n    },\n\n\n    /**\n     * Update the zero marker.\n     * @param {Number} steps Euclidean necklace node amount.\n     * @param {Number} rotation Euclidean necklace rotation.\n     */\n    updateZeroMarker = function updateZeroMarker(steps, rotation) {\n        var rad = doublePI * (-rotation / steps),\n            markerRadius = necklaceRadius + 15,\n            x = radius + Math.sin(rad) * markerRadius,\n            y = radius - Math.cos(rad) * markerRadius;\n\n        necklaceCtx.beginPath();\n        necklaceCtx.moveTo(x, y + zeroMarkerRadius);\n        necklaceCtx.arc(x, y, zeroMarkerRadius, 0, doublePI, true);\n        necklaceCtx.stroke();\n    },\n\n\n    /**\n     * Update the marker that indicates if the pattern is rotated.\n     * @param {Number} steps Euclidean necklace node amount.\n     * @param {Number} rotation Euclidean necklace rotation.\n     */\n    updateRotatedMarker = function updateRotatedMarker(steps, rotation) {\n        if (rotation !== 0) {\n            var x = radius,\n                y = radius - necklaceRadius - 10;\n\n            necklaceCtx.beginPath();\n            necklaceCtx.moveTo(x, y);\n            necklaceCtx.lineTo(x, y - 10);\n            necklaceCtx.lineTo(x + 6, y - 7);\n            necklaceCtx.lineTo(x, y - 4);\n            necklaceCtx.stroke();\n        }\n    },\n\n\n    /**\n     * Update the pattern's name.\n     */\n    updateName = function updateName() {\n        nameCtx.fillStyle = my.colorMid;\n        nameCtx.clearRect(0, 0, nameCanvas.width, nameCanvas.height);\n        nameCtx.fillText(my.params.name.value, nameCanvas.width / 2, nameCanvas.height / 2);\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Redraw the pattern's static shapes canvas.\n     */\n    redrawStaticCanvas = function redrawStaticCanvas() {\n        staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);\n        staticCtx.beginPath();\n\n        // necklace\n        staticCtx.drawImage(necklaceCanvas, 0, 0);\n\n        // center ring\n        staticCtx.moveTo(radius + centerRadius, radius);\n        staticCtx.arc(radius, radius, centerRadius, 0, doublePI, true);\n\n        // select circle\n        if (isSelected) {\n            staticCtx.moveTo(radius + selectRadius, radius);\n            staticCtx.arc(radius, radius, selectRadius, 0, doublePI, true);\n        }\n        staticCtx.stroke();\n    },\n\n\n    /**\n     * Add the pattern's static canvas to the main static canvas.\n     * @param  {Object} mainStaticCtx 2D canvas context.\n     */\n    addToStaticView = function addToStaticView(mainStaticCtx) {\n        mainStaticCtx.drawImage(staticCanvas, my.positionX - radius, my.positionY - radius);\n        mainStaticCtx.drawImage(nameCanvas, my.positionX - radius, my.positionY + necklaceRadius + 4);\n    },\n\n\n    /**\n     * Draw the pattern's dynamic shapes on the main dymamic canvas\n     * @param  {Object} mainStaticCtx 2D canvas context.\n     */\n    addToDynamicView = function addToDynamicView(mainDynamicCtx) {\n        // draw rotating pointer\n        mainDynamicCtx.save();\n        mainDynamicCtx.translate(my.positionX, my.positionY);\n        mainDynamicCtx.rotate(pointerRotation);\n        mainDynamicCtx.drawImage(pointerCanvas, -pointerCanvasCenter, -pointerCanvas.height);\n        mainDynamicCtx.restore();\n\n        mainDynamicCtx.fillStyle = my.colorHigh;\n        mainDynamicCtx.strokeStyle = my.colorHigh;\n        mainDynamicCtx.beginPath();\n\n        // necklace dots\n        isNoteActive = false;\n        var n = dotAnimations.length,\n            largestDot = dotRadius,\n            hasDotAnimations = false,\n            dotState = void 0,\n            x = void 0,\n            y = void 0;\n        for (var key in dotAnimations) {\n            if (dotAnimations.hasOwnProperty(key)) {\n                dotState = dotAnimations[key];\n                x = my.positionX + dotState.positionX;\n                y = my.positionY - dotState.positionY;\n                mainDynamicCtx.moveTo(x + dotState.dotRadius, y);\n                mainDynamicCtx.arc(x, y, dotState.dotRadius, 0, doublePI, true);\n                largestDot = Math.max(largestDot, dotState.dotRadius);\n                isNoteActive = true;\n            }\n        }\n\n        // center dot\n        if (isNoteActive) {\n            var largestDotNormalised = (largestDot - dotRadius) / (dotActiveRadius - dotRadius);\n            centerDotRadius = largestDotNormalised * centerDotFullRadius;\n            mainDynamicCtx.moveTo(my.positionX + centerDotRadius, my.positionY);\n            mainDynamicCtx.arc(my.positionX, my.positionY, centerDotRadius, 0, doublePI, true);\n        }\n\n        mainDynamicCtx.fill();\n        mainDynamicCtx.stroke();\n    },\n\n\n    /**\n     * Clear all this pattern's elements from the dynamic context.\n     * These are the center dot, necklace dots and pointer.\n     * @param  {Object} mainDynamicCtx 2D canvas context.\n     */\n    clearFromDynamicView = function clearFromDynamicView(mainDynamicCtx) {\n        // center dot\n        if (isNoteActive) {\n            mainDynamicCtx.clearRect(centerDotX, centerDotY, centerDotSize, centerDotSize);\n        }\n\n        // necklace dots\n        var rect = void 0;\n        for (var key in dotAnimations) {\n            if (dotAnimations.hasOwnProperty(key)) {\n                rect = dotAnimations[key].boundingBox;\n                mainDynamicCtx.clearRect(rect.xAbs, rect.yAbs, rect.height, rect.width);\n            }\n        }\n\n        // pointer\n        mainDynamicCtx.save();\n        mainDynamicCtx.translate(my.positionX, my.positionY);\n        mainDynamicCtx.rotate(pointerRotationPrevious);\n        mainDynamicCtx.clearRect(-pointerCanvasCenter, -pointerCanvas.height, pointerCanvas.width, pointerCanvas.height);\n        mainDynamicCtx.restore();\n    },\n\n\n    /**\n     * Test if a coordinate intersects with the graphic's hit area.\n     * @param  {Number} x Horizontal coordinate.\n     * @param  {Number} y Vertical coordinate.\n     * @return {Boolean} True if the point intersects. \n     */\n    intersectsWithPoint = function intersectsWithPoint(x, y) {\n        var distance = Math.sqrt(Math.pow(x - my.positionX, 2) + Math.pow(y - my.positionY, 2));\n        return distance <= necklaceRadius + dotRadius;\n    },\n\n\n    /**\n     * Set the theme colours of the processor view.\n     * @param {Object} theme Theme settings object.\n     */\n    setTheme = function setTheme(theme) {\n        my.colorHigh = theme.colorHigh;\n        my.colorMid = theme.colorMid;\n        my.colorLow = theme.colorLow;\n        staticCtx.strokeStyle = my.colorHigh;\n        necklaceCtx.fillStyle = my.colorHigh;\n        necklaceCtx.strokeStyle = my.colorHigh;\n        pointerCtx.strokeStyle = my.colorHigh;\n        updateName();\n        updateNecklace();\n    };\n\n    my = my || {};\n\n    that = (0, _canvasprocessorbase2.default)(specs, my);\n\n    initialise();\n\n    that.terminate = terminate;\n    that.setSelected = setSelected;\n    that.draw = draw;\n    that.addToStaticView = addToStaticView;\n    that.addToDynamicView = addToDynamicView;\n    that.clearFromDynamicView = clearFromDynamicView;\n    that.intersectsWithPoint = intersectsWithPoint;\n    that.setTheme = setTheme;\n    return that;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9lcGcvZ3JhcGhpYy5qcz8wNDVjIl0sIm5hbWVzIjpbImNyZWF0ZUdyYXBoaWMiLCJzcGVjcyIsIm15IiwidGhhdCIsImNhbnZhc0RpcnR5Q2FsbGJhY2siLCJzdGF0aWNDYW52YXMiLCJzdGF0aWNDdHgiLCJuZWNrbGFjZUNhbnZhcyIsIm5lY2tsYWNlQ3R4IiwibmFtZUNhbnZhcyIsIm5hbWVDdHgiLCJwb2ludGVyQ2FudmFzIiwicG9pbnRlckN0eCIsInBvaW50ZXJSb3RhdGlvbiIsInBvaW50ZXJSb3RhdGlvblByZXZpb3VzIiwicG9pbnRlck11dGVkUmFkaXVzIiwicG9pbnRlckNhbnZhc0NlbnRlciIsInJhZGl1cyIsIm5lY2tsYWNlTWluUmFkaXVzIiwibmVja2xhY2VSYWRpdXMiLCJjZW50ZXJEb3RGdWxsUmFkaXVzIiwiY2VudGVyRG90UmFkaXVzIiwiY2VudGVyRG90U2l6ZSIsImNlbnRlckRvdFgiLCJjZW50ZXJEb3RZIiwiY2VudGVyRG90U3RhcnRUd2VlbiIsImNlbnRlckRvdEVuZFR3ZWVuIiwiY2VudGVyUmFkaXVzIiwib3V0Q29ubmVjdG9yWSIsInNlbGVjdFJhZGl1cyIsImRvdFJhZGl1cyIsImRvdE1heFJhZGl1cyIsImRvdEFjdGl2ZVJhZGl1cyIsInplcm9NYXJrZXJSYWRpdXMiLCJsaW5lV2lkdGgiLCJpc1NlbGVjdGVkIiwiZG91YmxlUEkiLCJNYXRoIiwiUEkiLCJkb3RBbmltYXRpb25zIiwiaXNOb3RlQWN0aXZlIiwibmVja2xhY2UiLCJkdXJhdGlvbiIsImluaXRpYWxpc2UiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdG9yZSIsIlNUQVRFX0NIQU5HRSIsImhhbmRsZVN0YXRlQ2hhbmdlcyIsImluaXRHcmFwaGljcyIsInNldFRoZW1lIiwidGhlbWUiLCJ1cGRhdGVQb3NpdGlvbiIsImRhdGEiLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJyZWRyYXdTdGF0aWNDYW52YXMiLCJ1cGRhdGVEdXJhdGlvbiIsInRlcm1pbmF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwiZGV0YWlsIiwiYWN0aW9uIiwidHlwZSIsImFjdGlvbnMiLCJDSEFOR0VfUEFSQU1FVEVSIiwicHJvY2Vzc29ySUQiLCJpZCIsInBhcmFtcyIsInN0YXRlIiwicHJvY2Vzc29ycyIsImJ5SWQiLCJwYXJhbUtleSIsInVwZGF0ZU5lY2tsYWNlIiwidXBkYXRlUG9pbnRlciIsInVwZGF0ZU5hbWUiLCJEUkFHX1NFTEVDVEVEX1BST0NFU1NPUiIsIkRSQUdfQUxMX1BST0NFU1NPUlMiLCJwcm9jZXNzb3IiLCJjcmVhdGVFbGVtZW50IiwiaGVpZ2h0Iiwid2lkdGgiLCJnZXRDb250ZXh0IiwiZm9udCIsInRleHRBbGlnbiIsInNldFNlbGVjdGVkIiwiaXNTZWxlY3RlZFZpZXciLCJkcmF3IiwicG9zaXRpb24iLCJwcm9jZXNzb3JFdmVudHMiLCJzaG93UGxheWJhY2tQb3NpdGlvbiIsInVwZGF0ZU5vdGVBbmltYXRpb25zIiwibGVuZ3RoIiwiaSIsIm4iLCJldmVudCIsInN0YXJ0Tm90ZUFuaW1hdGlvbiIsInN0ZXBJbmRleCIsImRlbGF5RnJvbU5vd1RvTm90ZVN0YXJ0IiwiZGVsYXlGcm9tTm93VG9Ob3RlRW5kIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJvYmoiLCJrZXkiLCJpc0FjdGl2ZSIsIm5vdGVTdGFydERlbGF5Iiwibm90ZVN0b3BEZWxheSIsInN0ZXBzIiwidmFsdWUiLCJjZW50ZXIiLCJ4IiwieSIsImJvdW5kaW5nQm94IiwicmVjdCIsInNldFRpbWVvdXQiLCJ0d2VlbmluZ0RvdCIsInJhdGUiLCJpc190cmlwbGV0cyIsInN0ZXBEdXJhdGlvbiIsIlBQUU4iLCJwdWxzZXMiLCJyb3RhdGlvbiIsImV1Y2xpZCIsInJhZCIsIm1heCIsInNpbiIsImNvcyIsInB1c2giLCJ4QWJzIiwieUFicyIsImNsZWFyUmVjdCIsInVwZGF0ZU5lY2tsYWNlQWJzb2x1dGUiLCJ1cGRhdGVQb2x5Z29uIiwidXBkYXRlRG90cyIsInVwZGF0ZVplcm9NYXJrZXIiLCJ1cGRhdGVSb3RhdGVkTWFya2VyIiwiZmlsbFN0eWxlIiwiY29sb3JMb3ciLCJzdHJva2VTdHlsZSIsImJlZ2luUGF0aCIsImlzRmlyc3RQb2ludCIsImZpcnN0UG9pbnQiLCJkb3RDZW50ZXIiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJnbG9iYWxBbHBoYSIsImZpbGwiLCJjb2xvckhpZ2giLCJwb2ludCIsImFyYyIsImlzTXV0ZSIsImlzX211dGUiLCJwb2ludGVyUmFkaXVzIiwicG9pbnRlclgiLCJwb2ludGVyWSIsIm1hcmtlclJhZGl1cyIsImNvbG9yTWlkIiwiZmlsbFRleHQiLCJuYW1lIiwiZHJhd0ltYWdlIiwiYWRkVG9TdGF0aWNWaWV3IiwibWFpblN0YXRpY0N0eCIsImFkZFRvRHluYW1pY1ZpZXciLCJtYWluRHluYW1pY0N0eCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJyZXN0b3JlIiwibGFyZ2VzdERvdCIsImhhc0RvdEFuaW1hdGlvbnMiLCJkb3RTdGF0ZSIsImhhc093blByb3BlcnR5IiwibGFyZ2VzdERvdE5vcm1hbGlzZWQiLCJjbGVhckZyb21EeW5hbWljVmlldyIsImludGVyc2VjdHNXaXRoUG9pbnQiLCJkaXN0YW5jZSIsInNxcnQiLCJwb3ciXSwibWFwcGluZ3MiOiI7Ozs7O1FBT2dCQSxhLEdBQUFBLGE7O0FBUGhCOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7O0FBR08sU0FBU0EsYUFBVCxDQUF1QkMsS0FBdkIsRUFBOEJDLEVBQTlCLEVBQWtDO0FBQ3JDLFFBQUlDLGFBQUo7QUFBQSxRQUNJQyxzQkFBc0JILE1BQU1HLG1CQURoQztBQUFBLFFBRUlDLHFCQUZKO0FBQUEsUUFHSUMsa0JBSEo7QUFBQSxRQUlJQyx1QkFKSjtBQUFBLFFBS0lDLG9CQUxKO0FBQUEsUUFNSUMsbUJBTko7QUFBQSxRQU9JQyxnQkFQSjtBQUFBLFFBU0lDLHNCQVRKO0FBQUEsUUFVSUMs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QWMzRyxNQUFNMkcsUUFBcEI7QUFDQTVKLFdBQUd3SSxRQUFILEdBQWN2RixNQUFNdUYsUUFBcEI7QUFDQXBJLGtCQUFVcUksV0FBVixHQUF3QnpJLEdBQUdtSixTQUEzQjtBQUNBN0ksb0JBQVlpSSxTQUFaLEdBQXdCdkksR0FBR21KLFNBQTNCO0FBQ0E3SSxvQkFBWW1JLFdBQVosR0FBMEJ6SSxHQUFHbUosU0FBN0I7QUFDQXpJLG1CQUFXK0gsV0FBWCxHQUF5QnpJLEdBQUdtSixTQUE1QjtBQUNBMUU7QUFDQUY7QUFDSCxLQXRpQkw7O0FBd2lCQXZFLFNBQUtBLE1BQU0sRUFBWDs7QUFFQUMsV0FBTyxtQ0FBOEJGLEtBQTlCLEVBQXFDQyxFQUFyQyxDQUFQOztBQUVBeUM7O0FBRUF4QyxTQUFLdUQsU0FBTCxHQUFpQkEsU0FBakI7QUFDQXZELFNBQUtrRixXQUFMLEdBQW1CQSxXQUFuQjtBQUNBbEYsU0FBS29GLElBQUwsR0FBWUEsSUFBWjtBQUNBcEYsU0FBSytKLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EvSixTQUFLaUssZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUNBakssU0FBSzRLLG9CQUFMLEdBQTRCQSxvQkFBNUI7QUFDQTVLLFNBQUs2SyxtQkFBTCxHQUEyQkEsbUJBQTNCO0FBQ0E3SyxTQUFLK0MsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxXQUFPL0MsSUFBUDtBQUNIIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUNhbnZhc1Byb2Nlc3NvckJhc2VWaWV3IGZyb20gJy4uLy4uL3ZpZXcvY2FudmFzcHJvY2Vzc29yYmFzZS5qcyc7XG5pbXBvcnQgeyBnZXRFdWNsaWRQYXR0ZXJuLCByb3RhdGVFdWNsaWRQYXR0ZXJuIH0gZnJvbSAnLi9ldWNsaWQuanMnO1xuaW1wb3J0IHsgUFBRTiB9IGZyb20gJy4uLy4uL2NvcmUvY29uZmlnLmpzJztcblxuLyoqXG4gKiBFdWNsaWRlYW4gcGF0dGVybiBhbmltYXRlZCBuZWNrbGFjZSB3aGVlbCBkcmF3biBvbiBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHcmFwaGljKHNwZWNzLCBteSkge1xuICAgIGxldCB0aGF0LFxuICAgICAgICBjYW52YXNEaXJ0eUNhbGxiYWNrID0gc3BlY3MuY2FudmFzRGlydHlDYWxsYmFjayxcbiAgICAgICAgc3RhdGljQ2FudmFzLFxuICAgICAgICBzdGF0aWNDdHgsXG4gICAgICAgIG5lY2tsYWNlQ2FudmFzLFxuICAgICAgICBuZWNrbGFjZUN0eCxcbiAgICAgICAgbmFtZUNhbnZhcyxcbiAgICAgICAgbmFtZUN0eCxcblxuICAgICAgICBwb2ludGVyQ2FudmFzLFxuICAgICAgICBwb2ludGVyQ3R4LFxuICAgICAgICBwb2ludGVyUm90YXRpb24sXG4gICAgICAgIHBvaW50ZXJSb3RhdGlvblByZXZpb3VzID0gMCxcbiAgICAgICAgcG9pbnRlck11dGVkUmFkaXVzID0gMzAsXG4gICAgICAgIHBvaW50ZXJDYW52YXNDZW50ZXIsXG4gICAgICAgIFxuICAgICAgICByYWRpdXMgPSAxMTAsXG4gICAgICAgIG5lY2tsYWNlTWluUmFkaXVzID0gNTAsXG4gICAgICAgIG5lY2tsYWNlUmFkaXVzLFxuICAgICAgICBjZW50ZXJEb3RGdWxsUmFkaXVzID0gMTAsXG4gICAgICAgIGNlbnRlckRvdFJhZGl1cyxcbiAgICAgICAgY2VudGVyRG90U2l6ZSxcbiAgICAgICAgY2VudGVyRG90WCxcbiAgICAgICAgY2VudGVyRG90WSxcbiAgICAgICAgY2VudGVyRG90U3RhcnRUd2VlbixcbiAgICAgICAgY2VudGVyRG90RW5kVHdlZW4sXG4gICAgICAgIFxuICAgICAgICBjZW50ZXJSYWRpdXMgPSAyMCxcbiAgICAgICAgb3V0Q29ubmVjdG9yWSA9IDM1LFxuICAgICAgICBzZWxlY3RSYWRpdXMgPSAxNSxcbiAgICAgICAgZG90UmFkaXVzLFxuICAgICAgICBkb3RNYXhSYWRpdXMgPSAxMCxcbiAgICAgICAgZG90QWN0aXZlUmFkaXVzLFxuICAgICAgICB6ZXJvTWFya2VyUmFkaXVzID0gMyxcbiAgICAgICAgbGluZVdpZHRoID0gMixcbiAgICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlLFxuICAgICAgICBkb3VibGVQSSA9IE1hdGguUEkgKiAyLFxuICAgICAgICBkb3RBbmltYXRpb25zID0ge30sXG4gICAgICAgIGlzTm90ZUFjdGl2ZSA9IGZhbHNlLFxuICAgICAgICBuZWNrbGFjZSA9IFtdLFxuICAgICAgICBkdXJhdGlvbiA9IDAsXG4gICAgICAgIFxuICAgICAgICBpbml0aWFsaXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG15LnN0b3JlLlNUQVRFX0NIQU5HRSwgaGFuZGxlU3RhdGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIGNhbnZhc0RpcnR5Q2FsbGJhY2sgPSBzcGVjcy5jYW52YXNEaXJ0eUNhbGxiYWNrO1xuXG4gICAgICAgICAgICBpbml0R3JhcGhpY3MoKTtcbiAgICAgICAgICAgIHNldFRoZW1lKHNwZWNzLnRoZW1lKTtcbiAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKHNwZWNzLmRhdGEucG9zaXRpb25YLCBzcGVjcy5kYXRhLnBvc2l0aW9uWSk7XG4gICAgICAgICAgICByZWRyYXdTdGF0aWNDYW52YXMoKTtcbiAgICAgICAgICAgIHVwZGF0ZUR1cmF0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGJlZm9yZSB0aGlzIHZpZXcgaXMgZGVsZXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRlcm1pbmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihteS5zdG9yZS5TVEFURV9DSEFOR0UsIGhhbmRsZVN0YXRlQ2hhbmdlcyk7XG4gICAgICAgICAgICBjYW52YXNEaXJ0eUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVTdGF0ZUNoYW5nZXMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUuZGV0YWlsLmFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBlLmRldGFpbC5hY3Rpb25zLkNIQU5HRV9QQVJBTUVURVI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRldGFpbC5hY3Rpb24ucHJvY2Vzc29ySUQgPT09IG15LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBteS5wYXJhbXMgPSBlLmRldGFpbC5zdGF0ZS5wcm9jZXNzb3JzLmJ5SWRbbXkuaWRdLnBhcmFtcy5ieUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLmRldGFpbC5hY3Rpb24ucGFyYW1LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGVwcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVsc2VzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRHVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncm90YXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVOZWNrbGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpc19tdXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUG9pbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlTmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpc190cmlwbGV0cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbm90ZV9sZW5ndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEdXJhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgZS5kZXRhaWwuYWN0aW9ucy5EUkFHX1NFTEVDVEVEX1BST0NFU1NPUjpcbiAgICAgICAgICAgICAgICBjYXNlIGUuZGV0YWlsLmFjdGlvbnMuRFJBR19BTExfUFJPQ0VTU09SUzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gZS5kZXRhaWwuc3RhdGUucHJvY2Vzc29ycy5ieUlkW215LmlkXTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24ocHJvY2Vzc29yLnBvc2l0aW9uWCwgcHJvY2Vzc29yLnBvc2l0aW9uWSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRHcmFwaGljcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb2Zmc2NyZWVuIGNhbnZhcyBmb3Igc3RhdGljIHNoYXBlc1xuICAgICAgICAgICAgc3RhdGljQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBzdGF0aWNDYW52YXMuaGVpZ2h0ID0gcmFkaXVzICogMjtcbiAgICAgICAgICAgIHN0YXRpY0NhbnZhcy53aWR0aCA9IHJhZGl1cyAqIDI7XG4gICAgICAgICAgICBzdGF0aWNDdHggPSBzdGF0aWNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHN0YXRpY0N0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG9mZnNjcmVlbiBjYW52YXMgZm9yIGRvdHMgcmluZyBhbmQgcG9seWdvblxuICAgICAgICAgICAgbmVja2xhY2VDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIG5lY2tsYWNlQ2FudmFzLmhlaWdodCA9IHJhZGl1cyAqIDI7XG4gICAgICAgICAgICBuZWNrbGFjZUNhbnZhcy53aWR0aCA9IHJhZGl1cyAqIDI7XG4gICAgICAgICAgICBuZWNrbGFjZUN0eCA9IG5lY2tsYWNlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBuZWNrbGFjZUN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG9mZnNjcmVlbiBjYW52YXMgZm9yIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBwb2ludGVyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBwb2ludGVyQ2FudmFzLmhlaWdodCA9IHJhZGl1cztcbiAgICAgICAgICAgIHBvaW50ZXJDYW52YXMud2lkdGggPSBjZW50ZXJSYWRpdXMgKiAyO1xuICAgICAgICAgICAgcG9pbnRlckN0eCA9IHBvaW50ZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHBvaW50ZXJDdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgcG9pbnRlckNhbnZhc0NlbnRlciA9IHBvaW50ZXJDYW52YXMud2lkdGggLyAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBvZmZzY3JlZW4gY2FudmFzIGZvciB0aGUgbmFtZVxuICAgICAgICAgICAgbmFtZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgbmFtZUNhbnZhcy5oZWlnaHQgPSA0MDtcbiAgICAgICAgICAgIG5hbWVDYW52YXMud2lkdGggPSByYWRpdXMgKiAyO1xuICAgICAgICAgICAgbmFtZUN0eCA9IG5hbWVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIG5hbWVDdHguZm9udCA9ICcxNHB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgbmFtZUN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCB0byBjbGVhciBjZW50ZXIgZG90IFxuICAgICAgICAgICAgY2VudGVyRG90U2l6ZSA9IChjZW50ZXJEb3RGdWxsUmFkaXVzICsgMSkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgY2lyY2xlIGlmIHRoZSBteS5wcm9jZXNzb3IgaXMgc2VsZWN0ZWQsIGVsc2UgaGlkZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc1NlbGVjdGVkVmlldyBUcnVlIGlmIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbihpc1NlbGVjdGVkVmlldykge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWRWaWV3O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWRyYXdTdGF0aWNDYW52YXMgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2FudmFzRGlydHlDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVkcmF3U3RhdGljQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXcgPSBmdW5jdGlvbihwb3NpdGlvbiwgcHJvY2Vzc29yRXZlbnRzKSB7XG4gICAgICAgICAgICBzaG93UGxheWJhY2tQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICB1cGRhdGVOb3RlQW5pbWF0aW9ucygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocHJvY2Vzc29yRXZlbnRzW215LmlkXSAmJiBwcm9jZXNzb3JFdmVudHNbbXkuaWRdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcHJvY2Vzc29yRXZlbnRzW215LmlkXS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwcm9jZXNzb3JFdmVudHNbbXkuaWRdW2ldO1xuICAgICAgICAgICAgICAgICAgICBzdGFydE5vdGVBbmltYXRpb24oZXZlbnQuc3RlcEluZGV4LCBldmVudC5kZWxheUZyb21Ob3dUb05vdGVTdGFydCwgZXZlbnQuZGVsYXlGcm9tTm93VG9Ob3RlRW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgcGxheWJhY2sgcG9zaXRpb24gd2l0aGluIHRoZSBwYXR0ZXJuLlxuICAgICAgICAgKiBJbmRpY2F0ZWQgYnkgdGhlIHBvaW50ZXIncyByb3RhdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBwb3NpdGlvbiBQb3NpdGlvbiB3aXRoaW4gcGF0dGVybiBpbiB0aWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIHNob3dQbGF5YmFja1Bvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvaW50ZXJSb3RhdGlvblByZXZpb3VzID0gcG9pbnRlclJvdGF0aW9uO1xuICAgICAgICAgICAgcG9pbnRlclJvdGF0aW9uID0gZG91YmxlUEkgKiAocG9zaXRpb24gJSBkdXJhdGlvbiAvIGR1cmF0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBjdXJyZW50IG5hY2tsYWNlIGRvdCBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTm90ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRvdEFuaW1hdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBkb3RBbmltYXRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgb2JqLmRvdFJhZGl1cyAvPSAxLjE7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5pc0FjdGl2ZSAmJiBvYmouZG90UmFkaXVzIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG90QW5pbWF0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgYW5pbWF0aW9uIG9mIHRoZSBwYXR0ZXJuIGRvdCB0aGF0IGlzIGFib3V0IHRvIHBsYXkuIFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcEluZGV4IEluZGV4IG9mIHRoZSBzdGVwIHRvIHBsYXkuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBub3RlU3RhcnREZWxheSBEZWxheSBmcm9tIG5vdyB1bnRpbCBub3RlIHN0YXJ0IGluIG1zLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbm90ZVN0b3BEZWxheSBEZWxheSBmcm9tIG5vdyB1bnRpbCBub3RlIGVuZCBpbiBtcy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0Tm90ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKHN0ZXBJbmRleCwgbm90ZVN0YXJ0RGVsYXksIG5vdGVTdG9wRGVsYXkpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGRvdCBmb3IgdGhpcyBzdGVwXG4gICAgICAgICAgICBsZXQgc3RlcHMgPSBteS5wYXJhbXMuc3RlcHMudmFsdWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJldGFpbiBuZWNrbGFjZSBkb3Qgc3RhdGUgaW4gb2JqZWN0XG4gICAgICAgICAgICBkb3RBbmltYXRpb25zW3N0ZXBJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25YOiBuZWNrbGFjZVtzdGVwSW5kZXhdLmNlbnRlci54LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWTogbmVja2xhY2Vbc3RlcEluZGV4XS5jZW50ZXIueSxcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveDogbmVja2xhY2Vbc3RlcEluZGV4XS5yZWN0LFxuICAgICAgICAgICAgICAgIGRvdFJhZGl1czogMCxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGRlbGF5IHN0YXJ0IG9mIGFuaW1hdGlvblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR3ZWVuaW5nRG90ID0gZG90QW5pbWF0aW9uc1tzdGVwSW5kZXhdO1xuICAgICAgICAgICAgICAgIHR3ZWVuaW5nRG90LmRvdFJhZGl1cyA9IGRvdEFjdGl2ZVJhZGl1cztcbiAgICAgICAgICAgICAgICB0d2VlbmluZ0RvdC5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9LCBub3RlU3RhcnREZWxheSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgcGF0dGVybidzIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCByYXRlID0gbXkucGFyYW1zLmlzX3RyaXBsZXRzLnZhbHVlID8gbXkucGFyYW1zLnJhdGUudmFsdWUgKiAoMiAvIDMpIDogbXkucGFyYW1zLnJhdGUudmFsdWUsXG4gICAgICAgICAgICAgICAgc3RlcER1cmF0aW9uID0gcmF0ZSAqIFBQUU47XG4gICAgICAgICAgICBkdXJhdGlvbiA9IG15LnBhcmFtcy5zdGVwcy52YWx1ZSAqIHN0ZXBEdXJhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHBhdHRlcm4gZG90cy5cbiAgICAgICAgICogSWYgdGhlIHN0ZXBzLCBwdWxzZXMgb3Igcm90YXRpb24gcHJvcGVydGllcyBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAqIElmIHN0ZXBzIGNoYW5nZSBpdCBtaWdodCBpbnZhbGlkYXRlIHRoZSBwb2ludGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTmVja2xhY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBzdGVwcyA9IG15LnBhcmFtcy5zdGVwcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBwdWxzZXMgPSBteS5wYXJhbXMucHVsc2VzLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gbXkucGFyYW1zLnJvdGF0aW9uLnZhbHVlLFxuICAgICAgICAgICAgICAgIGV1Y2xpZCwgcmFkLCB4LCB5O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBldWNsaWQgPSBnZXRFdWNsaWRQYXR0ZXJuKHN0ZXBzLCBwdWxzZXMpO1xuICAgICAgICAgICAgZXVjbGlkID0gcm90YXRlRXVjbGlkUGF0dGVybihldWNsaWQsIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmVja2xhY2UgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkb3QgcG9zaXRpb25zXG4gICAgICAgICAgICBuZWNrbGFjZVJhZGl1cyA9IG5lY2tsYWNlTWluUmFkaXVzICsgKE1hdGgubWF4KDAsIHN0ZXBzIC0gMTYpICogMC44KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHJhZCA9IGRvdWJsZVBJICogKGkgLyBzdGVwcyk7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGguc2luKHJhZCkgKiBuZWNrbGFjZVJhZGl1cztcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5jb3MocmFkKSAqIG5lY2tsYWNlUmFkaXVzO1xuICAgICAgICAgICAgICAgIG5lY2tsYWNlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggLSBkb3RNYXhSYWRpdXMgKiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSArIGRvdE1heFJhZGl1cyAqIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4QWJzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeUFiczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZG90TWF4UmFkaXVzICogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkb3RNYXhSYWRpdXMgKiA0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmVja2xhY2VDdHguY2xlYXJSZWN0KDAsIDAsIG5lY2tsYWNlQ2FudmFzLndpZHRoLCBuZWNrbGFjZUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB1cGRhdGVOZWNrbGFjZUFic29sdXRlKCk7XG4gICAgICAgICAgICB1cGRhdGVQb2x5Z29uKHN0ZXBzLCBwdWxzZXMsIGV1Y2xpZCwgbmVja2xhY2UpO1xuICAgICAgICAgICAgdXBkYXRlRG90cyhzdGVwcywgZXVjbGlkLCBuZWNrbGFjZSk7XG4gICAgICAgICAgICB1cGRhdGVQb2ludGVyKCk7XG4gICAgICAgICAgICB1cGRhdGVaZXJvTWFya2VyKHN0ZXBzLCByb3RhdGlvbik7XG4gICAgICAgICAgICB1cGRhdGVSb3RhdGVkTWFya2VyKHN0ZXBzLCByb3RhdGlvbik7XG4gICAgICAgICAgICByZWRyYXdTdGF0aWNDYW52YXMoKTtcbiAgICAgICAgICAgIGNhbnZhc0RpcnR5Q2FsbGJhY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBuZWNrbGFjZSBub2RlcyByZWxhdGl2ZSB0byB0aGUgbWFpbiBjYW52YXMuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVOZWNrbGFjZUFic29sdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgcmVjdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmVja2xhY2UubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVjdCA9IG5lY2tsYWNlW2ldLnJlY3Q7XG4gICAgICAgICAgICAgICAgcmVjdC54QWJzID0gbXkucG9zaXRpb25YICsgcmVjdC54O1xuICAgICAgICAgICAgICAgIHJlY3QueUFicyA9IG15LnBvc2l0aW9uWSAtIHJlY3QueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgcGF0dGVybidzIHBvc2l0aW9uIG9uIHRoZSAyRCBjYW52YXMuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gdmFsdWUgTmV3IDJEIHBvc2l0aW9uIGFzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgbXkucG9zaXRpb25YID0geDtcbiAgICAgICAgICAgIG15LnBvc2l0aW9uWSA9IHk7XG4gICAgICAgICAgICBjZW50ZXJEb3RYID0gbXkucG9zaXRpb25YIC0gY2VudGVyRG90RnVsbFJhZGl1cyAtIDE7XG4gICAgICAgICAgICBjZW50ZXJEb3RZID0gbXkucG9zaXRpb25ZIC0gY2VudGVyRG90RnVsbFJhZGl1cyAtIDE7XG4gICAgICAgICAgICB1cGRhdGVOZWNrbGFjZUFic29sdXRlKCk7XG4gICAgICAgICAgICByZWRyYXdTdGF0aWNDYW52YXMoKTtcbiAgICAgICAgICAgIGNhbnZhc0RpcnR5Q2FsbGJhY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3IHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVQb2x5Z29uID0gZnVuY3Rpb24oc3RlcHMsIHB1bHNlcywgZXVjbGlkLCBuZWNrbGFjZSkge1xuICAgICAgICAgICAgaWYgKHB1bHNlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5maWxsU3R5bGUgPSBteS5jb2xvckxvdztcbiAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5zdHJva2VTdHlsZSA9IG15LmNvbG9yTG93O1xuICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGxldCBpc0ZpcnN0UG9pbnQgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFBvaW50LFxuICAgICAgICAgICAgICAgICAgICBkb3RDZW50ZXI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldWNsaWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdENlbnRlciA9IG5lY2tsYWNlW2ldLmNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFBvaW50ID0gZG90Q2VudGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4Lm1vdmVUbyhyYWRpdXMgKyBmaXJzdFBvaW50LngsIHJhZGl1cyAtIGZpcnN0UG9pbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4LmxpbmVUbyhyYWRpdXMgKyBkb3RDZW50ZXIueCwgcmFkaXVzIC0gZG90Q2VudGVyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4LmxpbmVUbyhyYWRpdXMgKyBmaXJzdFBvaW50LngsIHJhZGl1cyAtIGZpcnN0UG9pbnQueSk7XG4gICAgICAgICAgICAgICAgbmVja2xhY2VDdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgbmVja2xhY2VDdHguZ2xvYmFsQWxwaGEgPSAwLjY7XG4gICAgICAgICAgICAgICAgbmVja2xhY2VDdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXcgdGhlIG5lY2tsYWNlIGRvdHMgaW4gdGhlaXIgaW5hY3RpdmUgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEb3RzID0gZnVuY3Rpb24oc3RlcHMsIGV1Y2xpZCwgbmVja2xhY2UpIHtcbiAgICAgICAgICAgIGRvdFJhZGl1cyA9IGRvdE1heFJhZGl1cyAtIDMgLSAoTWF0aC5tYXgoMCwgc3RlcHMgLSAxNikgKiAwLjA5KTtcbiAgICAgICAgICAgIGRvdEFjdGl2ZVJhZGl1cyA9IGRvdFJhZGl1cyAqIDIuNTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmVja2xhY2VDdHguZmlsbFN0eWxlID0gbXkuY29sb3JIaWdoO1xuICAgICAgICAgICAgbmVja2xhY2VDdHguc3Ryb2tlU3R5bGUgPSBteS5jb2xvckhpZ2g7XG4gICAgICAgICAgICBsZXQgcG9pbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IG5lY2tsYWNlW2ldLmNlbnRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZXVjbGlkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdGl2ZSBkb3RcbiAgICAgICAgICAgICAgICAgICAgbmVja2xhY2VDdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4Lm1vdmVUbyhyYWRpdXMgKyBwb2ludC54ICsgZG90UmFkaXVzLCByYWRpdXMgLSBwb2ludC55KTtcbiAgICAgICAgICAgICAgICAgICAgbmVja2xhY2VDdHguYXJjKHJhZGl1cyArIHBvaW50LngsIHJhZGl1cyAtIHBvaW50LnksIGRvdFJhZGl1cywgMCwgZG91YmxlUEksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3NpdmUgZG90XG4gICAgICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5tb3ZlVG8ocmFkaXVzICsgcG9pbnQueCArIGRvdFJhZGl1cywgcmFkaXVzIC0gcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgICAgIG5lY2tsYWNlQ3R4LmFyYyhyYWRpdXMgKyBwb2ludC54LCByYWRpdXMgLSBwb2ludC55LCBkb3RSYWRpdXMsIDAsIGRvdWJsZVBJLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbmVja2xhY2VDdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgcG9pbnRlciB0aGF0IGNvbm5lY3RzIHRoZSBkb3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlUG9pbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGlzTXV0ZSA9IG15LnBhcmFtcy5pc19tdXRlLnZhbHVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJSYWRpdXMgPSBpc011dGUgPyBwb2ludGVyTXV0ZWRSYWRpdXMgOiBuZWNrbGFjZVJhZGl1cyxcbiAgICAgICAgICAgICAgICBwb2ludGVyWCA9IGlzTXV0ZSA/IDE1IDogMTksXG4gICAgICAgICAgICAgICAgcG9pbnRlclkgPSBpc011dGUgPyAxNSA6IDY7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBvaW50ZXJDdHguY2xlYXJSZWN0KDAsIDAsIHBvaW50ZXJDYW52YXMud2lkdGgsIHBvaW50ZXJDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHBvaW50ZXJDdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBwb2ludGVyQ3R4Lm1vdmVUbyhwb2ludGVyQ2FudmFzQ2VudGVyIC0gcG9pbnRlclgsIHBvaW50ZXJDYW52YXMuaGVpZ2h0IC0gcG9pbnRlclkpO1xuICAgICAgICAgICAgcG9pbnRlckN0eC5saW5lVG8ocG9pbnRlckNhbnZhc0NlbnRlciwgcG9pbnRlckNhbnZhcy5oZWlnaHQgLSBwb2ludGVyUmFkaXVzKTtcbiAgICAgICAgICAgIHBvaW50ZXJDdHgubGluZVRvKHBvaW50ZXJDYW52YXNDZW50ZXIgKyBwb2ludGVyWCwgcG9pbnRlckNhbnZhcy5oZWlnaHQgLSBwb2ludGVyWSk7XG4gICAgICAgICAgICBwb2ludGVyQ3R4LnN0cm9rZSgpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgemVybyBtYXJrZXIuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwcyBFdWNsaWRlYW4gbmVja2xhY2Ugbm9kZSBhbW91bnQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvbiBFdWNsaWRlYW4gbmVja2xhY2Ugcm90YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVaZXJvTWFya2VyID0gZnVuY3Rpb24oc3RlcHMsIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmFkID0gZG91YmxlUEkgKiAoLXJvdGF0aW9uIC8gc3RlcHMpLFxuICAgICAgICAgICAgICAgIG1hcmtlclJhZGl1cyA9IG5lY2tsYWNlUmFkaXVzICsgMTUsXG4gICAgICAgICAgICAgICAgeCA9IHJhZGl1cyArIChNYXRoLnNpbihyYWQpICogbWFya2VyUmFkaXVzKSxcbiAgICAgICAgICAgICAgICB5ID0gcmFkaXVzIC0gKE1hdGguY29zKHJhZCkgKiBtYXJrZXJSYWRpdXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZWNrbGFjZUN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIG5lY2tsYWNlQ3R4Lm1vdmVUbyh4LCB5ICsgemVyb01hcmtlclJhZGl1cyk7XG4gICAgICAgICAgICBuZWNrbGFjZUN0eC5hcmMoeCwgeSwgemVyb01hcmtlclJhZGl1cywgMCwgZG91YmxlUEksIHRydWUpO1xuICAgICAgICAgICAgbmVja2xhY2VDdHguc3Ryb2tlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBtYXJrZXIgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIHBhdHRlcm4gaXMgcm90YXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBzIEV1Y2xpZGVhbiBuZWNrbGFjZSBub2RlIGFtb3VudC5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uIEV1Y2xpZGVhbiBuZWNrbGFjZSByb3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVJvdGF0ZWRNYXJrZXIgPSBmdW5jdGlvbihzdGVwcywgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICB5ID0gcmFkaXVzIC0gbmVja2xhY2VSYWRpdXMgLSAxMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgbmVja2xhY2VDdHgubGluZVRvKHgsIHkgLSAxMCk7XG4gICAgICAgICAgICAgICAgbmVja2xhY2VDdHgubGluZVRvKHggKyA2LCB5IC0gNyk7XG4gICAgICAgICAgICAgICAgbmVja2xhY2VDdHgubGluZVRvKHgsIHkgLSA0KTtcbiAgICAgICAgICAgICAgICBuZWNrbGFjZUN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHBhdHRlcm4ncyBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbmFtZUN0eC5maWxsU3R5bGUgPSBteS5jb2xvck1pZDtcbiAgICAgICAgICAgIG5hbWVDdHguY2xlYXJSZWN0KDAsIDAsIG5hbWVDYW52YXMud2lkdGgsIG5hbWVDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIG5hbWVDdHguZmlsbFRleHQobXkucGFyYW1zLm5hbWUudmFsdWUsIG5hbWVDYW52YXMud2lkdGggLyAyLCBuYW1lQ2FudmFzLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjaygpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZHJhdyB0aGUgcGF0dGVybidzIHN0YXRpYyBzaGFwZXMgY2FudmFzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVkcmF3U3RhdGljQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdGF0aWNDdHguY2xlYXJSZWN0KDAsIDAsIHN0YXRpY0NhbnZhcy53aWR0aCwgc3RhdGljQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBzdGF0aWNDdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG5lY2tsYWNlXG4gICAgICAgICAgICBzdGF0aWNDdHguZHJhd0ltYWdlKG5lY2tsYWNlQ2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY2VudGVyIHJpbmdcbiAgICAgICAgICAgIHN0YXRpY0N0eC5tb3ZlVG8ocmFkaXVzICsgY2VudGVyUmFkaXVzLCByYWRpdXMpO1xuICAgICAgICAgICAgc3RhdGljQ3R4LmFyYyhyYWRpdXMsIHJhZGl1cywgY2VudGVyUmFkaXVzLCAwLCBkb3VibGVQSSwgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNlbGVjdCBjaXJjbGVcbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ3R4Lm1vdmVUbyhyYWRpdXMgKyBzZWxlY3RSYWRpdXMsIHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgc3RhdGljQ3R4LmFyYyhyYWRpdXMsIHJhZGl1cywgc2VsZWN0UmFkaXVzLCAwLCBkb3VibGVQSSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0aWNDdHguc3Ryb2tlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHRoZSBwYXR0ZXJuJ3Mgc3RhdGljIGNhbnZhcyB0byB0aGUgbWFpbiBzdGF0aWMgY2FudmFzLlxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG1haW5TdGF0aWNDdHggMkQgY2FudmFzIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRUb1N0YXRpY1ZpZXcgPSBmdW5jdGlvbihtYWluU3RhdGljQ3R4KSB7XG4gICAgICAgICAgICBtYWluU3RhdGljQ3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBzdGF0aWNDYW52YXMsXG4gICAgICAgICAgICAgICAgbXkucG9zaXRpb25YIC0gcmFkaXVzLFxuICAgICAgICAgICAgICAgIG15LnBvc2l0aW9uWSAtIHJhZGl1cyk7XG4gICAgICAgICAgICBtYWluU3RhdGljQ3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBuYW1lQ2FudmFzLFxuICAgICAgICAgICAgICAgIG15LnBvc2l0aW9uWCAtIHJhZGl1cyxcbiAgICAgICAgICAgICAgICBteS5wb3NpdGlvblkgKyBuZWNrbGFjZVJhZGl1cyArIDQpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXcgdGhlIHBhdHRlcm4ncyBkeW5hbWljIHNoYXBlcyBvbiB0aGUgbWFpbiBkeW1hbWljIGNhbnZhc1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG1haW5TdGF0aWNDdHggMkQgY2FudmFzIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRUb0R5bmFtaWNWaWV3ID0gZnVuY3Rpb24obWFpbkR5bmFtaWNDdHgpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgcm90YXRpbmcgcG9pbnRlclxuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHguc2F2ZSgpO1xuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHgudHJhbnNsYXRlKG15LnBvc2l0aW9uWCwgbXkucG9zaXRpb25ZKTtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnJvdGF0ZShwb2ludGVyUm90YXRpb24pO1xuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHguZHJhd0ltYWdlKHBvaW50ZXJDYW52YXMsIC1wb2ludGVyQ2FudmFzQ2VudGVyLCAtcG9pbnRlckNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5maWxsU3R5bGUgPSBteS5jb2xvckhpZ2g7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5zdHJva2VTdHlsZSA9IG15LmNvbG9ySGlnaDtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBuZWNrbGFjZSBkb3RzXG4gICAgICAgICAgICBpc05vdGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBuID0gZG90QW5pbWF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbGFyZ2VzdERvdCA9IGRvdFJhZGl1cyxcbiAgICAgICAgICAgICAgICBoYXNEb3RBbmltYXRpb25zID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZG90U3RhdGUsIHgsIHk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZG90QW5pbWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChkb3RBbmltYXRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90U3RhdGUgPSBkb3RBbmltYXRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHggPSBteS5wb3NpdGlvblggKyBkb3RTdGF0ZS5wb3NpdGlvblg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBteS5wb3NpdGlvblkgLSBkb3RTdGF0ZS5wb3NpdGlvblk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4Lm1vdmVUbyh4ICsgZG90U3RhdGUuZG90UmFkaXVzLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHguYXJjKHgsIHksIGRvdFN0YXRlLmRvdFJhZGl1cywgMCwgZG91YmxlUEksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsYXJnZXN0RG90ID0gTWF0aC5tYXgobGFyZ2VzdERvdCwgZG90U3RhdGUuZG90UmFkaXVzKTtcbiAgICAgICAgICAgICAgICAgICAgaXNOb3RlQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNlbnRlciBkb3RcbiAgICAgICAgICAgIGlmIChpc05vdGVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFyZ2VzdERvdE5vcm1hbGlzZWQgPSAobGFyZ2VzdERvdCAtIGRvdFJhZGl1cykgLyAoZG90QWN0aXZlUmFkaXVzIC0gZG90UmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjZW50ZXJEb3RSYWRpdXMgPSBsYXJnZXN0RG90Tm9ybWFsaXNlZCAqIGNlbnRlckRvdEZ1bGxSYWRpdXM7XG4gICAgICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHgubW92ZVRvKG15LnBvc2l0aW9uWCArIGNlbnRlckRvdFJhZGl1cywgbXkucG9zaXRpb25ZKTtcbiAgICAgICAgICAgICAgICBtYWluRHluYW1pY0N0eC5hcmMobXkucG9zaXRpb25YLCBteS5wb3NpdGlvblksIGNlbnRlckRvdFJhZGl1cywgMCwgZG91YmxlUEksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5maWxsKCk7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5zdHJva2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgdGhpcyBwYXR0ZXJuJ3MgZWxlbWVudHMgZnJvbSB0aGUgZHluYW1pYyBjb250ZXh0LlxuICAgICAgICAgKiBUaGVzZSBhcmUgdGhlIGNlbnRlciBkb3QsIG5lY2tsYWNlIGRvdHMgYW5kIHBvaW50ZXIuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gbWFpbkR5bmFtaWNDdHggMkQgY2FudmFzIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckZyb21EeW5hbWljVmlldyA9IGZ1bmN0aW9uKG1haW5EeW5hbWljQ3R4KSB7XG4gICAgICAgICAgICAvLyBjZW50ZXIgZG90XG4gICAgICAgICAgICBpZiAoaXNOb3RlQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHguY2xlYXJSZWN0KGNlbnRlckRvdFgsIGNlbnRlckRvdFksIGNlbnRlckRvdFNpemUsIGNlbnRlckRvdFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBuZWNrbGFjZSBkb3RzXG4gICAgICAgICAgICBsZXQgcmVjdDtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkb3RBbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvdEFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gZG90QW5pbWF0aW9uc1trZXldLmJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICAgICAgICBtYWluRHluYW1pY0N0eC5jbGVhclJlY3QocmVjdC54QWJzLCByZWN0LnlBYnMsIHJlY3QuaGVpZ2h0LCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHBvaW50ZXJcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnNhdmUoKTtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnRyYW5zbGF0ZShteS5wb3NpdGlvblgsIG15LnBvc2l0aW9uWSk7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5yb3RhdGUocG9pbnRlclJvdGF0aW9uUHJldmlvdXMpO1xuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHguY2xlYXJSZWN0KC1wb2ludGVyQ2FudmFzQ2VudGVyLCAtcG9pbnRlckNhbnZhcy5oZWlnaHQsIHBvaW50ZXJDYW52YXMud2lkdGgsIHBvaW50ZXJDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGlmIGEgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdyYXBoaWMncyBoaXQgYXJlYS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB4IEhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB5IFZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBvaW50IGludGVyc2VjdHMuIFxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0c1dpdGhQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gbXkucG9zaXRpb25YLCAyKSArIE1hdGgucG93KHkgLSBteS5wb3NpdGlvblksIDIpKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZSA8PSBuZWNrbGFjZVJhZGl1cyArIGRvdFJhZGl1cztcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRoZW1lIGNvbG91cnMgb2YgdGhlIHByb2Nlc3NvciB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhlbWUgVGhlbWUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGhlbWUgPSBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICAgICAgbXkuY29sb3JIaWdoID0gdGhlbWUuY29sb3JIaWdoO1xuICAgICAgICAgICAgbXkuY29sb3JNaWQgPSB0aGVtZS5jb2xvck1pZDtcbiAgICAgICAgICAgIG15LmNvbG9yTG93ID0gdGhlbWUuY29sb3JMb3c7XG4gICAgICAgICAgICBzdGF0aWNDdHguc3Ryb2tlU3R5bGUgPSBteS5jb2xvckhpZ2g7XG4gICAgICAgICAgICBuZWNrbGFjZUN0eC5maWxsU3R5bGUgPSBteS5jb2xvckhpZ2g7XG4gICAgICAgICAgICBuZWNrbGFjZUN0eC5zdHJva2VTdHlsZSA9IG15LmNvbG9ySGlnaDtcbiAgICAgICAgICAgIHBvaW50ZXJDdHguc3Ryb2tlU3R5bGUgPSBteS5jb2xvckhpZ2g7XG4gICAgICAgICAgICB1cGRhdGVOYW1lKCk7XG4gICAgICAgICAgICB1cGRhdGVOZWNrbGFjZSgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICBteSA9IG15IHx8IHt9O1xuICAgIFxuICAgIHRoYXQgPSBjcmVhdGVDYW52YXNQcm9jZXNzb3JCYXNlVmlldyhzcGVjcywgbXkpO1xuICAgIFxuICAgIGluaXRpYWxpc2UoKTtcbiAgICBcbiAgICB0aGF0LnRlcm1pbmF0ZSA9IHRlcm1pbmF0ZTtcbiAgICB0aGF0LnNldFNlbGVjdGVkID0gc2V0U2VsZWN0ZWQ7XG4gICAgdGhhdC5kcmF3ID0gZHJhdztcbiAgICB0aGF0LmFkZFRvU3RhdGljVmlldyA9IGFkZFRvU3RhdGljVmlldztcbiAgICB0aGF0LmFkZFRvRHluYW1pY1ZpZXcgPSBhZGRUb0R5bmFtaWNWaWV3O1xuICAgIHRoYXQuY2xlYXJGcm9tRHluYW1pY1ZpZXcgPSBjbGVhckZyb21EeW5hbWljVmlldztcbiAgICB0aGF0LmludGVyc2VjdHNXaXRoUG9pbnQgPSBpbnRlcnNlY3RzV2l0aFBvaW50O1xuICAgIHRoYXQuc2V0VGhlbWUgPSBzZXRUaGVtZTtcbiAgICByZXR1cm4gdGhhdDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9lcGcvZ3JhcGhpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n");

/***/ }),

/***/ 40:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createGraphic = createGraphic;\n\nvar _canvasprocessorbase = __webpack_require__(35);\n\nvar _canvasprocessorbase2 = _interopRequireDefault(_canvasprocessorbase);\n\nvar _euclid = __webpack_require__(37);\n\nvar _config = __webpack_require__(8);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Euclidean pattern animated necklace wheel drawn on canvas.\n */\nfunction createGraphic(specs, my) {\n    var that = void 0,\n        canvasDirtyCallback = void 0,\n        staticCtx = void 0,\n        rotateCtx = void 0,\n        pointerCtx = void 0,\n        nameCtx = void 0,\n        duration = 0,\n        euclid = void 0,\n        status = true,\n        isSelected = false,\n        isNoteActive = false,\n        pointerRotation = void 0,\n        pointerRotationPrevious = 0,\n        centerDotCounter = 0,\n        centerDotNextStartTime = 0,\n        centerDotFullRadius = 10,\n        lineWidth = 2,\n        radius = 70,\n        centerRadius = 20,\n        selectRadius = 15,\n        innerRadius = 30,\n        outerRadius = 46,\n        dotRadius = 10,\n        locatorLength = 38,\n        zeroMarkerRadius = 2,\n        zeroMarkerY = radius - centerRadius - zeroMarkerRadius - 3,\n        pointerCanvasCenter = centerRadius,\n        locatorTop = radius - pointerCanvasCenter - locatorLength,\n        doublePI = Math.PI * 2,\n        initialise = function initialise() {\n        document.addEventListener(my.store.STATE_CHANGE, handleStateChanges);\n        canvasDirtyCallback = specs.canvasDirtyCallback;\n        initGraphics();\n        updateEuclid(specs.data.params.byId);\n        setTheme(specs.theme);\n        updatePosition(specs.data.positionX, specs.data.positionY);\n        updateDuration(specs.data.params.byId);\n        redrawStaticCanvas();\n        redrawPointerCanvas();\n        redrawRotatingCanvas();\n    },\n\n\n    /**\n     * Called before this view is deleted.\n     */\n    terminate = function terminate() {\n        document.removeEventListener(my.store.STATE_CHANGE, handleStateChanges);\n        canvasDirtyCallback = null;\n    },\n        handleStateChanges = function handleStateChanges(e) {\n        switch (e.detail.action.type) {\n\n            case e.detail.actions.CHANGE_PARAMETER:\n            case e.detail.actions.RECREATE_PARAMETER:\n                if (e.detail.action.processorID === my.id) {\n                    my.params = e.detail.state.processors.byId[my.id].params.byId;\n                    switch (e.detail.action.paramKey) {\n                        case 'steps':\n                            updateDuration(e.detail.state.processors.byId[my.id].params.byId);\n                        // fall through\n                        case 'pulses':\n                            updateEuclid(e.detail.state.processors.byId[my.id].params.byId);\n                            redrawRotatingCanvas();\n                            break;\n                        case 'rotation':\n                            canvasDirtyCallback();\n                            break;\n                        case 'is_triplets':\n                        case 'rate':\n                            updateDuration(e.detail.state.processors.byId[my.id].params.byId);\n                            break;\n                        case 'name':\n                            updateName(e.detail.state.processors.byId[my.id].params.byId);\n                            break;\n                    }\n                }\n                break;\n\n            case e.detail.actions.DRAG_SELECTED_PROCESSOR:\n            case e.detail.actions.DRAG_ALL_PROCESSORS:\n                var processor = e.detail.state.processors.byId[my.id];\n                updatePosition(processor.positionX, processor.positionY);\n                break;\n        }\n    },\n        initGraphics = function initGraphics() {\n        // offscreen canvas for static shapes\n        var canvas = document.createElement('canvas');\n        canvas.height = radius * 2;\n        canvas.width = radius * 2;\n        staticCtx = canvas.getContext('2d');\n        staticCtx.lineWidth = lineWidth;\n\n        // offscreen canvas for dots ring and polygon\n        canvas = document.createElement('canvas');\n        canvas.height = radius * 2;\n        canvas.width = radius * 2;\n        rotateCtx = canvas.getContext('2d');\n        rotateCtx.lineWidth = lineWidth;\n\n        // offscreen canvas for the pointer\n        canvas = document.createElement('canvas');\n        canvas.height = radius;\n        canvas.width = centerRadius * 2;\n        pointerCtx = canvas.getContext('2d');\n        pointerCtx.lineWidth = lineWidth;\n        pointerCtx.lineJoin = 'bevel';\n\n        // offscreen canvas for the name\n        canvas = document.createElement('canvas');\n        canvas.height = 40;\n        canvas.width = radius * 2;\n        nameCtx = canvas.getContext('2d');\n        nameCtx.font = '14px sans-serif';\n        nameCtx.textAlign = 'center';\n    },\n\n\n    /**\n     * Update pattern's position on the 2D canvas.\n     * @param  {Object} value New 2D position as object.\n     */\n    updatePosition = function updatePosition(x, y) {\n        my.positionX = x;\n        my.positionY = y;\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Calculate the pattern's duration in milliseconds.\n     */\n    updateDuration = function updateDuration(params) {\n        var rate = params.is_triplets.value ? params.rate.value * (2 / 3) : params.rate.value,\n            stepDuration = rate * _config.PPQN;\n        duration = params.steps.value * stepDuration;\n    },\n        updateEuclid = function updateEuclid(params) {\n        euclid = (0, _euclid.getEuclidPattern)(params.steps.value, params.pulses.value);\n    },\n\n\n    /**\n     * Update the pattern's name.\n     */\n    updateName = function updateName(params) {\n        nameCtx.fillStyle = my.colorMid;\n        nameCtx.clearRect(0, 0, nameCtx.canvas.width, nameCtx.canvas.height);\n        nameCtx.fillText(params.name.value, nameCtx.canvas.width / 2, nameCtx.canvas.height / 2);\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Show the playback position within the pattern.\n     * Indicated by the pointer's rotation.\n     * @param  {Number} position Position within pattern in ticks.\n     */\n    updatePlaybackPosition = function updatePlaybackPosition(position) {\n        pointerRotationPrevious = pointerRotation;\n        pointerRotation = -doublePI * (position % duration / duration);\n    },\n\n\n    /**\n     * Redraw the pattern's static shapes canvas.\n     */\n    redrawStaticCanvas = function redrawStaticCanvas() {\n        staticCtx.clearRect(0, 0, staticCtx.canvas.width, staticCtx.canvas.height);\n        staticCtx.beginPath();\n\n        // center ring\n        staticCtx.moveTo(radius + centerRadius, radius);\n        staticCtx.arc(radius, radius, centerRadius, 0, doublePI);\n\n        // select circle\n        if (isSelected) {\n            staticCtx.moveTo(radius + selectRadius, radius);\n            staticCtx.arc(radius, radius, selectRadius, 0, doublePI);\n        }\n\n        staticCtx.stroke();\n    },\n\n\n    /**\n     * Redraw the location pointer and the status dot.\n     */\n    redrawPointerCanvas = function redrawPointerCanvas() {\n        var necklacePos = radius - (status ? outerRadius : innerRadius),\n            halfWayPos = necklacePos + (locatorTop - necklacePos) / 2,\n            statusWidth = status ? 15 : 6,\n            sides = status ? locatorTop : halfWayPos;\n\n        pointerCtx.clearRect(0, 0, pointerCtx.canvas.width, pointerCtx.canvas.height);\n        pointerCtx.beginPath();\n\n        // position locator\n        pointerCtx.moveTo(pointerCanvasCenter, radius - pointerCanvasCenter);\n        pointerCtx.lineTo(pointerCanvasCenter, locatorTop);\n\n        // status indicator\n        pointerCtx.lineTo(pointerCanvasCenter - statusWidth, sides);\n        pointerCtx.lineTo(pointerCanvasCenter, necklacePos);\n        pointerCtx.lineTo(pointerCanvasCenter + statusWidth, sides);\n        pointerCtx.lineTo(pointerCanvasCenter, locatorTop);\n\n        pointerCtx.stroke();\n    },\n\n\n    /**\n     * The rotating canvas shows the necklace shape.\n     */\n    redrawRotatingCanvas = function redrawRotatingCanvas() {\n        var arc = void 0,\n            x = void 0,\n            y = void 0;\n\n        rotateCtx.clearRect(0, 0, rotateCtx.canvas.width, rotateCtx.canvas.height);\n        rotateCtx.fillStyle = my.colorHigh;\n        rotateCtx.strokeStyle = my.colorHigh;\n        rotateCtx.beginPath();\n\n        for (var i = 0, n = euclid.length; i < n; i++) {\n            var stepRadius = euclid[i] ? outerRadius : innerRadius;\n            rotateCtx.arc(radius, radius, stepRadius, i / n * doublePI - Math.PI / 2, (i + 1) / n * doublePI - Math.PI / 2, false);\n        }\n        // for (let i = 0, n = euclid.length; i < n; i++) {\n        //     const stepRadius = euclid[i] ? outerRadius : innerRadius;\n        //     rotateCtx.arc(radius, radius, stepRadius, ((n - i) / n) * doublePI, ((n - i - 1) / n) * doublePI, true);\n        // }\n\n        rotateCtx.closePath();\n        rotateCtx.stroke();\n\n        // zero marker\n        rotateCtx.beginPath();\n        rotateCtx.moveTo(radius + zeroMarkerRadius, zeroMarkerY);\n        rotateCtx.arc(radius, zeroMarkerY, zeroMarkerRadius, 0, doublePI, true);\n        rotateCtx.fill();\n    },\n\n\n    /**\n     * Show circle if the my.processor is selected, else hide.\n     * @param {Boolean} isSelectedView True if selected.\n     */\n    setSelected = function setSelected(isSelectedView) {\n        isSelected = isSelectedView;\n        if (typeof redrawStaticCanvas == 'function' && typeof canvasDirtyCallback == 'function') {\n            redrawStaticCanvas();\n            canvasDirtyCallback();\n        }\n    },\n        draw = function draw(position, processorEvents) {\n        updatePlaybackPosition(position);\n\n        // calculate status and redraw locator if needed\n        var currentStep = Math.floor(position % duration / duration * my.params.steps.value);\n        currentStep = (currentStep + my.params.rotation.value) % my.params.steps.value;\n        var currentStatus = euclid[currentStep];\n        if (currentStatus !== status) {\n            status = currentStatus;\n            redrawPointerCanvas();\n            canvasDirtyCallback();\n        }\n\n        // Show notes to happen as center dot animation.\n        if (processorEvents[my.id] && processorEvents[my.id].length) {\n            for (var i = 0, n = processorEvents[my.id].length; i < n; i++) {\n                var event = processorEvents[my.id][i];\n                centerDotNextStartTime = performance.now() + event.delayFromNowToNoteStart;\n                centerDotCounter = 1;\n            }\n        }\n    },\n\n\n    /**\n     * Add the pattern's static canvas to the main static canvas.\n     * @param  {Object} mainStaticCtx 2D canvas context.\n     */\n    addToStaticView = function addToStaticView(mainStaticCtx) {\n        // draw static canvas\n        mainStaticCtx.drawImage(staticCtx.canvas, my.positionX - radius, my.positionY - radius);\n\n        // draw name canvas\n        mainStaticCtx.drawImage(nameCtx.canvas, my.positionX - radius, my.positionY + outerRadius + 4);\n\n        // draw pointer canvas\n        var patternRotation = my.params.rotation.value / my.params.steps.value * doublePI;\n        mainStaticCtx.save();\n        mainStaticCtx.translate(my.positionX, my.positionY);\n        mainStaticCtx.rotate(patternRotation);\n        mainStaticCtx.drawImage(pointerCtx.canvas, -pointerCanvasCenter, -pointerCtx.canvas.height);\n        mainStaticCtx.restore();\n    },\n\n\n    /**\n     * Draw the pattern's dynamic shapes on the main dymamic canvas\n     * @param  {Object} mainStaticCtx 2D canvas context.\n     */\n    addToDynamicView = function addToDynamicView(mainDynamicCtx) {\n        // draw rotating canvas\n        mainDynamicCtx.save();\n        mainDynamicCtx.translate(my.positionX, my.positionY);\n        mainDynamicCtx.rotate(pointerRotation);\n        mainDynamicCtx.drawImage(rotateCtx.canvas, -radius, -radius);\n        mainDynamicCtx.restore();\n\n        // center dot\n        if (centerDotCounter >= 0 && centerDotNextStartTime < performance.now()) {\n            var centerDotRadius = centerDotFullRadius * centerDotCounter;\n            mainDynamicCtx.moveTo(my.positionX + centerDotRadius, my.positionY);\n            mainDynamicCtx.arc(my.positionX, my.positionY, centerDotRadius, 0, doublePI, true);\n            mainDynamicCtx.fill();\n            centerDotCounter -= .1;\n        }\n    },\n\n\n    /**\n     * Clear all this pattern's elements from the dynamic context.\n     * These are the center dot, necklace dots and pointer.\n     * @param  {Object} mainDynamicCtx 2D canvas context.\n     */\n    clearFromDynamicView = function clearFromDynamicView(mainDynamicCtx) {\n        mainDynamicCtx.save();\n        mainDynamicCtx.translate(my.positionX, my.positionY);\n        mainDynamicCtx.rotate(pointerRotationPrevious);\n        mainDynamicCtx.clearRect(-radius, -radius, rotateCtx.canvas.width, rotateCtx.canvas.height);\n        mainDynamicCtx.restore();\n    },\n\n\n    /**\n     * Test if a coordinate intersects with the graphic's hit area.\n     * @param  {Number} x Horizontal coordinate.\n     * @param  {Number} y Vertical coordinate.\n     * @return {Boolean} True if the point intersects. \n     */\n    intersectsWithPoint = function intersectsWithPoint(x, y, canvasRect) {\n        var distance = Math.sqrt(Math.pow(x - my.positionX, 2) + Math.pow(y - my.positionY, 2));\n        return distance <= centerRadius;\n    },\n\n\n    /**\n     * Set the theme colours of the processor view.\n     * @param {Object} theme Theme settings object.\n     */\n    setTheme = function setTheme(theme) {\n        my.colorHigh = theme.colorHigh;\n        my.colorMid = theme.colorMid;\n        my.colorLow = theme.colorLow;\n        staticCtx.strokeStyle = my.colorHigh;\n        staticCtx.fillStyle = my.colorHigh;\n        rotateCtx.strokeStyle = my.colorHigh;\n        pointerCtx.strokeStyle = my.colorHigh;\n        pointerCtx.fillStyle = my.colorHigh;\n\n        updateName(my.store.getState().processors.byId[my.id].params.byId);\n        redrawStaticCanvas();\n        redrawRotatingCanvas();\n        redrawPointerCanvas();\n    };\n\n    my = my || {};\n\n    that = (0, _canvasprocessorbase2.default)(specs, my);\n\n    initialise();\n\n    that.terminate = terminate;\n    that.setSelected = setSelected;\n    that.draw = draw;\n    that.addToStaticView = addToStaticView;\n    that.addToDynamicView = addToDynamicView;\n    that.clearFromDynamicView = clearFromDynamicView;\n    that.intersectsWithPoint = intersectsWithPoint;\n    that.setTheme = setTheme;\n    return that;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9ldWNsaWRmeC9ncmFwaGljLmpzP2NjZTUiXSwibmFtZXMiOlsiY3JlYXRlR3JhcGhpYyIsInNwZWNzIiwibXkiLCJ0aGF0IiwiY2FudmFzRGlydHlDYWxsYmFjayIsInN0YXRpY0N0eCIsInJvdGF0ZUN0eCIsInBvaW50ZXJDdHgiLCJuYW1lQ3R4IiwiZHVyYXRpb24iLCJldWNsaWQiLCJzdGF0dXMiLCJpc1NlbGVjdGVkIiwiaXNOb3RlQWN0aXZlIiwicG9pbnRlclJvdGF0aW9uIiwicG9pbnRlclJvdGF0aW9uUHJldmlvdXMiLCJjZW50ZXJEb3RDb3VudGVyIiwiY2VudGVyRG90TmV4dFN0YXJ0VGltZSIsImNlbnRlckRvdEZ1bGxSYWRpdXMiLCJsaW5lV2lkdGgiLCJyYWRpdXMiLCJjZW50ZXJSYWRpdXMiLCJzZWxlY3RSYWRpdXMiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiZG90UmFkaXVzIiwibG9jYXRvckxlbmd0aCIsInplcm9NYXJrZXJSYWRpdXMiLCJ6ZXJvTWFya2VyWSIsInBvaW50ZXJDYW52YXNDZW50ZXIiLCJsb2NhdG9yVG9wIiwiZG91YmxlUEkiLCJNYXRoIiwiUEkiLCJpbml0aWFsaXNlIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwic3RvcmUiLCJTVEFURV9DSEFOR0UiLCJoYW5kbGVTdGF0ZUNoYW5nZXMiLCJpbml0R3JhcGhpY3MiLCJ1cGRhdGVFdWNsaWQiLCJkYXRhIiwicGFyYW1zIiwiYnlJZCIsInNldFRoZW1lIiwidGhlbWUiLCJ1cGRhdGVQb3NpdGlvbiIsInBvc2l0aW9uWCIsInBvc2l0aW9uWSIsInVwZGF0ZUR1cmF0aW9uIiwicmVkcmF3U3RhdGljQ2FudmFzIiwicmVkcmF3UG9pbnRlckNhbnZhcyIsInJlZHJhd1JvdGF0aW5nQ2FudmFzIiwidGVybWluYXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImUiLCJkZXRhaWwiLCJhY3Rpb24iLCJ0eXBlIiwiYWN0aW9ucyIsIkNIQU5HRV9QQVJBTUVURVIiLCJSRUNSRUFURV9QQVJBTUVURVIiLCJwcm9jZXNzb3JJRCIsImlkIiwic3RhdGUiLCJwcm9jZXNzb3JzIiwicGFyYW1LZXkiLCJ1cGRhdGVOYW1lIiwiRFJBR19TRUxFQ1RFRF9QUk9DRVNTT1IiLCJEUkFHX0FMTF9QUk9DRVNTT1JTIiwicHJvY2Vzc29yIiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImhlaWdodCIsIndpZHRoIiwiZ2V0Q29udGV4dCIsImxpbmVKb2luIiwiZm9udCIsInRleHRBbGlnbiIsIngiLCJ5IiwicmF0ZSIsImlzX3RyaXBsZXRzIiwidmFsdWUiLCJzdGVwRHVyYXRpb24iLCJQUFFOIiwic3RlcHMiLCJwdWxzZXMiLCJmaWxsU3R5bGUiLCJjb2xvck1pZCIsImNsZWFyUmVjdCIsImZpbGxUZXh0IiwibmFtZSIsInVwZGF0ZVBsYXliYWNrUG9zaXRpb24iLCJwb3NpdGlvbiIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImFyYyIsInN0cm9rZSIsIm5lY2tsYWNlUG9zIiwiaGFsZldheVBvcyIsInN0YXR1c1dpZHRoIiwic2lkZXMiLCJsaW5lVG8iLCJjb2xvckhpZ2giLCJzdHJva2VTdHlsZSIsImkiLCJuIiwibGVuZ3RoIiwic3RlcFJhZGl1cyIsImNsb3NlUGF0aCIsImZpbGwiLCJzZXRTZWxlY3RlZCIsImlzU2VsZWN0ZWRWaWV3IiwiZHJhdyIsInByb2Nlc3NvckV2ZW50cyIsImN1cnJlbnRTdGVwIiwiZmxvb3IiLCJyb3RhdGlvbiIsImN1cnJlbnRTdGF0dXMiLCJldmVudCIsInBlcmZvcm1hbmNlIiwibm93IiwiZGVsYXlGcm9tTm93VG9Ob3RlU3RhcnQiLCJhZGRUb1N0YXRpY1ZpZXciLCJtYWluU3RhdGljQ3R4IiwiZHJhd0ltYWdlIiwicGF0dGVyblJvdGF0aW9uIiwic2F2ZSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlc3RvcmUiLCJhZGRUb0R5bmFtaWNWaWV3IiwibWFpbkR5bmFtaWNDdHgiLCJjZW50ZXJEb3RSYWRpdXMiLCJjbGVhckZyb21EeW5hbWljVmlldyIsImludGVyc2VjdHNXaXRoUG9pbnQiLCJjYW52YXNSZWN0IiwiZGlzdGFuY2UiLCJzcXJ0IiwicG93IiwiY29sb3JMb3ciLCJnZXRTdGF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFPZ0JBLGEsR0FBQUEsYTs7QUFQaEI7Ozs7QUFDQTs7QUFDQTs7OztBQUVBOzs7QUFHTyxTQUFTQSxhQUFULENBQXVCQyxLQUF2QixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDckMsUUFBSUMsYUFBSjtBQUFBLFFBQ0lDLDRCQURKO0FBQUEsUUFFSUMsa0JBRko7QUFBQSxRQUdJQyxrQkFISjtBQUFBLFFBSUlDLG1CQUpKO0FBQUEsUUFLSUMsZ0JBTEo7QUFBQSxRQU9JQyxXQUFXLENBUGY7QUFBQSxRQVFJQyxlQVJKO0FBQUEsUUFTSUMsU0FBUyxJQVRiO0FBQUEsUUFVSUMsYUFBYSxLQVZqQjtBQUFBLFFBV0lDLGVBQWUsS0FYbkI7QUFBQSxRQVlJQyx3QkFaSjtBQUFBLFFBYUlDLDBCQUEwQixDQWI5QjtBQUFBLFFBY0lDLG1CQUFtQixDQWR2QjtBQUFBLFFBZUlDLHlCQUF5QixDQWY3QjtBQUFBLFFBaUJJQyxzQkFBc0IsRUFqQjFCO0FBQUEsUUFrQklDLFlBQVksQ0FsQmhCO0FBQUEsUUFtQklDLFNBQVMsRUFuQmI7QUFBQSxRQW9CSUMsZUFBZSxFQXBCbkI7QUFBQSxRQXFCSUMsZUFBZSxFQXJCbkI7QUFBQSxRQXNCSUMsY0FBYyxFQXRCbEI7QUFBQSxRQXVCSUMsY0FBYyxFQXZCbEI7QUFBQSxRQXdCSUMsWUFBWSxFQXhCaEI7QUFBQSxRQXlCSUMsZ0JBQWdCLEVBekJwQjtBQUFBLFFBMEJJQyxtQkFBbUIsQ0ExQnZCO0FBQUEsUUEyQklDLGNBQWNSLFNBQVNDLFlBQVQsR0FBd0JNLGdCQUF4QixHQUEyQyxDQTNCN0Q7QUFBQSxRQTRCSUUsc0JBQXNCUixZQTVCMUI7QUFBQSxRQTZCSVMsYUFBYVYsU0FBU1MsbUJBQVQsR0FBK0JILGFBN0Jo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R0FBR3VHLFNBQXpCO0FBQ0FuRyxrQkFBVW9HLFdBQVYsR0FBd0J4RyxHQUFHdUcsU0FBM0I7QUFDQWxHLG1CQUFXbUcsV0FBWCxHQUF5QnhHLEdBQUd1RyxTQUE1QjtBQUNBbEcsbUJBQVdrRixTQUFYLEdBQXVCdkYsR0FBR3VHLFNBQTFCOztBQUVBckMsbUJBQVdsRSxHQUFHbUMsS0FBSCxDQUFTMEcsUUFBVCxHQUFvQjdFLFVBQXBCLENBQStCdEIsSUFBL0IsQ0FBb0MxQyxHQUFHOEQsRUFBdkMsRUFBMkNyQixNQUEzQyxDQUFrREMsSUFBN0Q7QUFDQU87QUFDQUU7QUFDQUQ7QUFDSCxLQTdXTDs7QUErV0lsRCxTQUFLQSxNQUFNLEVBQVg7O0FBRUpDLFdBQU8sbUNBQThCRixLQUE5QixFQUFxQ0MsRUFBckMsQ0FBUDs7QUFFQWdDOztBQUVBL0IsU0FBS21ELFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0FuRCxTQUFLOEcsV0FBTCxHQUFtQkEsV0FBbkI7QUFDQTlHLFNBQUtnSCxJQUFMLEdBQVlBLElBQVo7QUFDQWhILFNBQUswSCxlQUFMLEdBQXVCQSxlQUF2QjtBQUNBMUgsU0FBS2tJLGdCQUFMLEdBQXdCQSxnQkFBeEI7QUFDQWxJLFNBQUtxSSxvQkFBTCxHQUE0QkEsb0JBQTVCO0FBQ0FySSxTQUFLc0ksbUJBQUwsR0FBMkJBLG1CQUEzQjtBQUNBdEksU0FBSzBDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsV0FBTzFDLElBQVA7QUFDSCIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVDYW52YXNQcm9jZXNzb3JCYXNlVmlldyBmcm9tICcuLi8uLi92aWV3L2NhbnZhc3Byb2Nlc3NvcmJhc2UuanMnO1xuaW1wb3J0IHsgZ2V0RXVjbGlkUGF0dGVybiwgcm90YXRlRXVjbGlkUGF0dGVybiB9IGZyb20gJy4vZXVjbGlkLmpzJztcbmltcG9ydCB7IFBQUU4gfSBmcm9tICcuLi8uLi9jb3JlL2NvbmZpZy5qcyc7XG5cbi8qKlxuICogRXVjbGlkZWFuIHBhdHRlcm4gYW5pbWF0ZWQgbmVja2xhY2Ugd2hlZWwgZHJhd24gb24gY2FudmFzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGhpYyhzcGVjcywgbXkpIHtcbiAgICBsZXQgdGhhdCxcbiAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjayxcbiAgICAgICAgc3RhdGljQ3R4LFxuICAgICAgICByb3RhdGVDdHgsXG4gICAgICAgIHBvaW50ZXJDdHgsXG4gICAgICAgIG5hbWVDdHgsXG5cbiAgICAgICAgZHVyYXRpb24gPSAwLFxuICAgICAgICBldWNsaWQsXG4gICAgICAgIHN0YXR1cyA9IHRydWUsXG4gICAgICAgIGlzU2VsZWN0ZWQgPSBmYWxzZSxcbiAgICAgICAgaXNOb3RlQWN0aXZlID0gZmFsc2UsXG4gICAgICAgIHBvaW50ZXJSb3RhdGlvbixcbiAgICAgICAgcG9pbnRlclJvdGF0aW9uUHJldmlvdXMgPSAwLFxuICAgICAgICBjZW50ZXJEb3RDb3VudGVyID0gMCxcbiAgICAgICAgY2VudGVyRG90TmV4dFN0YXJ0VGltZSA9IDAsXG5cbiAgICAgICAgY2VudGVyRG90RnVsbFJhZGl1cyA9IDEwLFxuICAgICAgICBsaW5lV2lkdGggPSAyLFxuICAgICAgICByYWRpdXMgPSA3MCxcbiAgICAgICAgY2VudGVyUmFkaXVzID0gMjAsXG4gICAgICAgIHNlbGVjdFJhZGl1cyA9IDE1LFxuICAgICAgICBpbm5lclJhZGl1cyA9IDMwLFxuICAgICAgICBvdXRlclJhZGl1cyA9IDQ2LFxuICAgICAgICBkb3RSYWRpdXMgPSAxMCxcbiAgICAgICAgbG9jYXRvckxlbmd0aCA9IDM4LFxuICAgICAgICB6ZXJvTWFya2VyUmFkaXVzID0gMixcbiAgICAgICAgemVyb01hcmtlclkgPSByYWRpdXMgLSBjZW50ZXJSYWRpdXMgLSB6ZXJvTWFya2VyUmFkaXVzIC0gMyxcbiAgICAgICAgcG9pbnRlckNhbnZhc0NlbnRlciA9IGNlbnRlclJhZGl1cyxcbiAgICAgICAgbG9jYXRvclRvcCA9IHJhZGl1cyAtIHBvaW50ZXJDYW52YXNDZW50ZXIgLSBsb2NhdG9yTGVuZ3RoLFxuICAgICAgICBkb3VibGVQSSA9IE1hdGguUEkgKiAyLFxuXG4gICAgICAgIGluaXRpYWxpc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobXkuc3RvcmUuU1RBVEVfQ0hBTkdFLCBoYW5kbGVTdGF0ZUNoYW5nZXMpO1xuICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjayA9IHNwZWNzLmNhbnZhc0RpcnR5Q2FsbGJhY2s7XG4gICAgICAgICAgICBpbml0R3JhcGhpY3MoKTtcbiAgICAgICAgICAgIHVwZGF0ZUV1Y2xpZChzcGVjcy5kYXRhLnBhcmFtcy5ieUlkKTtcbiAgICAgICAgICAgIHNldFRoZW1lKHNwZWNzLnRoZW1lKTtcbiAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKHNwZWNzLmRhdGEucG9zaXRpb25YLCBzcGVjcy5kYXRhLnBvc2l0aW9uWSk7XG4gICAgICAgICAgICB1cGRhdGVEdXJhdGlvbihzcGVjcy5kYXRhLnBhcmFtcy5ieUlkKTtcbiAgICAgICAgICAgIHJlZHJhd1N0YXRpY0NhbnZhcygpO1xuICAgICAgICAgICAgcmVkcmF3UG9pbnRlckNhbnZhcygpO1xuICAgICAgICAgICAgcmVkcmF3Um90YXRpbmdDYW52YXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYmVmb3JlIHRoaXMgdmlldyBpcyBkZWxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGVybWluYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG15LnN0b3JlLlNUQVRFX0NIQU5HRSwgaGFuZGxlU3RhdGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIGNhbnZhc0RpcnR5Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgaGFuZGxlU3RhdGVDaGFuZ2VzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc3dpdGNoIChlLmRldGFpbC5hY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgZS5kZXRhaWwuYWN0aW9ucy5DSEFOR0VfUEFSQU1FVEVSOlxuICAgICAgICAgICAgICAgIGNhc2UgZS5kZXRhaWwuYWN0aW9ucy5SRUNSRUFURV9QQVJBTUVURVI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRldGFpbC5hY3Rpb24ucHJvY2Vzc29ySUQgPT09IG15LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBteS5wYXJhbXMgPSBlLmRldGFpbC5zdGF0ZS5wcm9jZXNzb3JzLmJ5SWRbbXkuaWRdLnBhcmFtcy5ieUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLmRldGFpbC5hY3Rpb24ucGFyYW1LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGVwcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUR1cmF0aW9uKGUuZGV0YWlsLnN0YXRlLnByb2Nlc3NvcnMuYnlJZFtteS5pZF0ucGFyYW1zLmJ5SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwdWxzZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVFdWNsaWQoZS5kZXRhaWwuc3RhdGUucHJvY2Vzc29ycy5ieUlkW215LmlkXS5wYXJhbXMuYnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZHJhd1JvdGF0aW5nQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JvdGF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpc190cmlwbGV0cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUR1cmF0aW9uKGUuZGV0YWlsLnN0YXRlLnByb2Nlc3NvcnMuYnlJZFtteS5pZF0ucGFyYW1zLmJ5SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlTmFtZShlLmRldGFpbC5zdGF0ZS5wcm9jZXNzb3JzLmJ5SWRbbXkuaWRdLnBhcmFtcy5ieUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIGUuZGV0YWlsLmFjdGlvbnMuRFJBR19TRUxFQ1RFRF9QUk9DRVNTT1I6XG4gICAgICAgICAgICAgICAgY2FzZSBlLmRldGFpbC5hY3Rpb25zLkRSQUdfQUxMX1BST0NFU1NPUlM6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGUuZGV0YWlsLnN0YXRlLnByb2Nlc3NvcnMuYnlJZFtteS5pZF07XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKHByb2Nlc3Nvci5wb3NpdGlvblgsIHByb2Nlc3Nvci5wb3NpdGlvblkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbml0R3JhcGhpY3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG9mZnNjcmVlbiBjYW52YXMgZm9yIHN0YXRpYyBzaGFwZXNcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByYWRpdXMgKiAyO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcmFkaXVzICogMjtcbiAgICAgICAgICAgIHN0YXRpY0N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgc3RhdGljQ3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgLy8gb2Zmc2NyZWVuIGNhbnZhcyBmb3IgZG90cyByaW5nIGFuZCBwb2x5Z29uXG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByYWRpdXMgKiAyO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcmFkaXVzICogMjtcbiAgICAgICAgICAgIHJvdGF0ZUN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgcm90YXRlQ3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgLy8gb2Zmc2NyZWVuIGNhbnZhcyBmb3IgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHJhZGl1cztcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNlbnRlclJhZGl1cyAqIDI7XG4gICAgICAgICAgICBwb2ludGVyQ3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBwb2ludGVyQ3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHBvaW50ZXJDdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBvZmZzY3JlZW4gY2FudmFzIGZvciB0aGUgbmFtZVxuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gNDA7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSByYWRpdXMgKiAyO1xuICAgICAgICAgICAgbmFtZUN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgbmFtZUN0eC5mb250ID0gJzE0cHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICBuYW1lQ3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBwYXR0ZXJuJ3MgcG9zaXRpb24gb24gdGhlIDJEIGNhbnZhcy5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZSBOZXcgMkQgcG9zaXRpb24gYXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICBteS5wb3NpdGlvblggPSB4O1xuICAgICAgICAgICAgbXkucG9zaXRpb25ZID0geTtcbiAgICAgICAgICAgIGNhbnZhc0RpcnR5Q2FsbGJhY2soKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBwYXR0ZXJuJ3MgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdGUgPSBwYXJhbXMuaXNfdHJpcGxldHMudmFsdWUgPyBwYXJhbXMucmF0ZS52YWx1ZSAqICgyIC8gMykgOiBwYXJhbXMucmF0ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBzdGVwRHVyYXRpb24gPSByYXRlICogUFBRTjtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gcGFyYW1zLnN0ZXBzLnZhbHVlICogc3RlcER1cmF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUV1Y2xpZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgZXVjbGlkID0gZ2V0RXVjbGlkUGF0dGVybihwYXJhbXMuc3RlcHMudmFsdWUsIHBhcmFtcy5wdWxzZXMudmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgcGF0dGVybidzIG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVOYW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICBuYW1lQ3R4LmZpbGxTdHlsZSA9IG15LmNvbG9yTWlkO1xuICAgICAgICAgICAgbmFtZUN0eC5jbGVhclJlY3QoMCwgMCwgbmFtZUN0eC5jYW52YXMud2lkdGgsIG5hbWVDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBuYW1lQ3R4LmZpbGxUZXh0KHBhcmFtcy5uYW1lLnZhbHVlLCBuYW1lQ3R4LmNhbnZhcy53aWR0aCAvIDIsIG5hbWVDdHguY2FudmFzLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjaygpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIHBsYXliYWNrIHBvc2l0aW9uIHdpdGhpbiB0aGUgcGF0dGVybi5cbiAgICAgICAgICogSW5kaWNhdGVkIGJ5IHRoZSBwb2ludGVyJ3Mgcm90YXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gcG9zaXRpb24gUG9zaXRpb24gd2l0aGluIHBhdHRlcm4gaW4gdGlja3MuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVQbGF5YmFja1Bvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBvaW50ZXJSb3RhdGlvblByZXZpb3VzID0gcG9pbnRlclJvdGF0aW9uO1xuICAgICAgICAgICAgcG9pbnRlclJvdGF0aW9uID0gLWRvdWJsZVBJICogKChwb3NpdGlvbiAlIGR1cmF0aW9uKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWRyYXcgdGhlIHBhdHRlcm4ncyBzdGF0aWMgc2hhcGVzIGNhbnZhcy5cbiAgICAgICAgICovXG4gICAgICAgIHJlZHJhd1N0YXRpY0NhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RhdGljQ3R4LmNsZWFyUmVjdCgwLCAwLCBzdGF0aWNDdHguY2FudmFzLndpZHRoLCBzdGF0aWNDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBzdGF0aWNDdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIC8vIGNlbnRlciByaW5nXG4gICAgICAgICAgICBzdGF0aWNDdHgubW92ZVRvKHJhZGl1cyArIGNlbnRlclJhZGl1cywgcmFkaXVzKTtcbiAgICAgICAgICAgIHN0YXRpY0N0eC5hcmMocmFkaXVzLCByYWRpdXMsIGNlbnRlclJhZGl1cywgMCwgZG91YmxlUEkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZWxlY3QgY2lyY2xlXG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHN0YXRpY0N0eC5tb3ZlVG8ocmFkaXVzICsgc2VsZWN0UmFkaXVzLCByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHN0YXRpY0N0eC5hcmMocmFkaXVzLCByYWRpdXMsIHNlbGVjdFJhZGl1cywgMCwgZG91YmxlUEkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0aWNDdHguc3Ryb2tlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZHJhdyB0aGUgbG9jYXRpb24gcG9pbnRlciBhbmQgdGhlIHN0YXR1cyBkb3QuXG4gICAgICAgICAqL1xuICAgICAgICByZWRyYXdQb2ludGVyQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBuZWNrbGFjZVBvcyA9IHJhZGl1cyAtIChzdGF0dXMgPyBvdXRlclJhZGl1cyA6IGlubmVyUmFkaXVzKSxcbiAgICAgICAgICAgICAgICBoYWxmV2F5UG9zID0gbmVja2xhY2VQb3MgKyAoKGxvY2F0b3JUb3AgLSBuZWNrbGFjZVBvcykgLyAyKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNXaWR0aCA9IHN0YXR1cyA/IDE1IDogNixcbiAgICAgICAgICAgICAgICBzaWRlcyA9IHN0YXR1cyA/IGxvY2F0b3JUb3AgOiBoYWxmV2F5UG9zO1xuXG4gICAgICAgICAgICBwb2ludGVyQ3R4LmNsZWFyUmVjdCgwLCAwLCBwb2ludGVyQ3R4LmNhbnZhcy53aWR0aCwgcG9pbnRlckN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHBvaW50ZXJDdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIGxvY2F0b3JcbiAgICAgICAgICAgIHBvaW50ZXJDdHgubW92ZVRvKHBvaW50ZXJDYW52YXNDZW50ZXIsIHJhZGl1cyAtIHBvaW50ZXJDYW52YXNDZW50ZXIpO1xuICAgICAgICAgICAgcG9pbnRlckN0eC5saW5lVG8ocG9pbnRlckNhbnZhc0NlbnRlciwgbG9jYXRvclRvcCk7XG5cbiAgICAgICAgICAgIC8vIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgICAgICAgIHBvaW50ZXJDdHgubGluZVRvKHBvaW50ZXJDYW52YXNDZW50ZXIgLSBzdGF0dXNXaWR0aCwgc2lkZXMpO1xuICAgICAgICAgICAgcG9pbnRlckN0eC5saW5lVG8ocG9pbnRlckNhbnZhc0NlbnRlciwgbmVja2xhY2VQb3MpO1xuICAgICAgICAgICAgcG9pbnRlckN0eC5saW5lVG8ocG9pbnRlckNhbnZhc0NlbnRlciArIHN0YXR1c1dpZHRoLCBzaWRlcyk7XG4gICAgICAgICAgICBwb2ludGVyQ3R4LmxpbmVUbyhwb2ludGVyQ2FudmFzQ2VudGVyLCBsb2NhdG9yVG9wKTtcblxuICAgICAgICAgICAgcG9pbnRlckN0eC5zdHJva2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvdGF0aW5nIGNhbnZhcyBzaG93cyB0aGUgbmVja2xhY2Ugc2hhcGUuXG4gICAgICAgICAqL1xuICAgICAgICByZWRyYXdSb3RhdGluZ0NhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGFyYywgeCwgeTtcblxuICAgICAgICAgICAgcm90YXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCByb3RhdGVDdHguY2FudmFzLndpZHRoLCByb3RhdGVDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICByb3RhdGVDdHguZmlsbFN0eWxlID0gbXkuY29sb3JIaWdoO1xuICAgICAgICAgICAgcm90YXRlQ3R4LnN0cm9rZVN0eWxlID0gbXkuY29sb3JIaWdoO1xuICAgICAgICAgICAgcm90YXRlQ3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGV1Y2xpZC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwUmFkaXVzID0gZXVjbGlkW2ldID8gb3V0ZXJSYWRpdXMgOiBpbm5lclJhZGl1cztcbiAgICAgICAgICAgICAgICByb3RhdGVDdHguYXJjKHJhZGl1cywgcmFkaXVzLCBzdGVwUmFkaXVzLCAoKGkgLyBuKSAqIGRvdWJsZVBJKSAtIChNYXRoLlBJIC8gMiksICgoKGkgKyAxKSAvIG4pICogZG91YmxlUEkpIC0gKE1hdGguUEkgLyAyKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDAsIG4gPSBldWNsaWQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc3Qgc3RlcFJhZGl1cyA9IGV1Y2xpZFtpXSA/IG91dGVyUmFkaXVzIDogaW5uZXJSYWRpdXM7XG4gICAgICAgICAgICAvLyAgICAgcm90YXRlQ3R4LmFyYyhyYWRpdXMsIHJhZGl1cywgc3RlcFJhZGl1cywgKChuIC0gaSkgLyBuKSAqIGRvdWJsZVBJLCAoKG4gLSBpIC0gMSkgLyBuKSAqIGRvdWJsZVBJLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgcm90YXRlQ3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgcm90YXRlQ3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyB6ZXJvIG1hcmtlclxuICAgICAgICAgICAgcm90YXRlQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcm90YXRlQ3R4Lm1vdmVUbyhyYWRpdXMgKyB6ZXJvTWFya2VyUmFkaXVzLCB6ZXJvTWFya2VyWSk7XG4gICAgICAgICAgICByb3RhdGVDdHguYXJjKHJhZGl1cyAsIHplcm9NYXJrZXJZLCB6ZXJvTWFya2VyUmFkaXVzLCAwLCBkb3VibGVQSSwgdHJ1ZSk7XG4gICAgICAgICAgICByb3RhdGVDdHguZmlsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgY2lyY2xlIGlmIHRoZSBteS5wcm9jZXNzb3IgaXMgc2VsZWN0ZWQsIGVsc2UgaGlkZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc1NlbGVjdGVkVmlldyBUcnVlIGlmIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbihpc1NlbGVjdGVkVmlldykge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWRWaWV3O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWRyYXdTdGF0aWNDYW52YXMgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2FudmFzRGlydHlDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVkcmF3U3RhdGljQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZHJhdyA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBwcm9jZXNzb3JFdmVudHMpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBsYXliYWNrUG9zaXRpb24ocG9zaXRpb24pO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgc3RhdHVzIGFuZCByZWRyYXcgbG9jYXRvciBpZiBuZWVkZWRcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RlcCA9IE1hdGguZmxvb3IoKChwb3NpdGlvbiAlIGR1cmF0aW9uKSAvIGR1cmF0aW9uKSAqIG15LnBhcmFtcy5zdGVwcy52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50U3RlcCA9IChjdXJyZW50U3RlcCArIG15LnBhcmFtcy5yb3RhdGlvbi52YWx1ZSkgJSBteS5wYXJhbXMuc3RlcHMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gZXVjbGlkW2N1cnJlbnRTdGVwXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBjdXJyZW50U3RhdHVzO1xuICAgICAgICAgICAgICAgIHJlZHJhd1BvaW50ZXJDYW52YXMoKTtcbiAgICAgICAgICAgICAgICBjYW52YXNEaXJ0eUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3cgbm90ZXMgdG8gaGFwcGVuIGFzIGNlbnRlciBkb3QgYW5pbWF0aW9uLlxuICAgICAgICAgICAgaWYgKHByb2Nlc3NvckV2ZW50c1tteS5pZF0gJiYgcHJvY2Vzc29yRXZlbnRzW215LmlkXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHByb2Nlc3NvckV2ZW50c1tteS5pZF0ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcHJvY2Vzc29yRXZlbnRzW215LmlkXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyRG90TmV4dFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZXZlbnQuZGVsYXlGcm9tTm93VG9Ob3RlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlckRvdENvdW50ZXIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdGhlIHBhdHRlcm4ncyBzdGF0aWMgY2FudmFzIHRvIHRoZSBtYWluIHN0YXRpYyBjYW52YXMuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gbWFpblN0YXRpY0N0eCAyRCBjYW52YXMgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGFkZFRvU3RhdGljVmlldyA9IGZ1bmN0aW9uKG1haW5TdGF0aWNDdHgpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgc3RhdGljIGNhbnZhc1xuICAgICAgICAgICAgbWFpblN0YXRpY0N0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgc3RhdGljQ3R4LmNhbnZhcyxcbiAgICAgICAgICAgICAgICBteS5wb3NpdGlvblggLSByYWRpdXMsXG4gICAgICAgICAgICAgICAgbXkucG9zaXRpb25ZIC0gcmFkaXVzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZHJhdyBuYW1lIGNhbnZhc1xuICAgICAgICAgICAgbWFpblN0YXRpY0N0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgbmFtZUN0eC5jYW52YXMsXG4gICAgICAgICAgICAgICAgbXkucG9zaXRpb25YIC0gcmFkaXVzLFxuICAgICAgICAgICAgICAgIG15LnBvc2l0aW9uWSArIG91dGVyUmFkaXVzICsgNCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGRyYXcgcG9pbnRlciBjYW52YXNcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuUm90YXRpb24gPSAobXkucGFyYW1zLnJvdGF0aW9uLnZhbHVlIC8gbXkucGFyYW1zLnN0ZXBzLnZhbHVlKSAqIGRvdWJsZVBJO1xuICAgICAgICAgICAgbWFpblN0YXRpY0N0eC5zYXZlKCk7XG4gICAgICAgICAgICBtYWluU3RhdGljQ3R4LnRyYW5zbGF0ZShteS5wb3NpdGlvblgsIG15LnBvc2l0aW9uWSk7XG4gICAgICAgICAgICBtYWluU3RhdGljQ3R4LnJvdGF0ZShwYXR0ZXJuUm90YXRpb24pO1xuICAgICAgICAgICAgbWFpblN0YXRpY0N0eC5kcmF3SW1hZ2UocG9pbnRlckN0eC5jYW52YXMsIC1wb2ludGVyQ2FudmFzQ2VudGVyLCAtcG9pbnRlckN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1haW5TdGF0aWNDdHgucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXcgdGhlIHBhdHRlcm4ncyBkeW5hbWljIHNoYXBlcyBvbiB0aGUgbWFpbiBkeW1hbWljIGNhbnZhc1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG1haW5TdGF0aWNDdHggMkQgY2FudmFzIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRUb0R5bmFtaWNWaWV3ID0gZnVuY3Rpb24obWFpbkR5bmFtaWNDdHgpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgcm90YXRpbmcgY2FudmFzXG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5zYXZlKCk7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC50cmFuc2xhdGUobXkucG9zaXRpb25YLCBteS5wb3NpdGlvblkpO1xuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHgucm90YXRlKHBvaW50ZXJSb3RhdGlvbik7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5kcmF3SW1hZ2Uocm90YXRlQ3R4LmNhbnZhcywgLXJhZGl1cywgLXJhZGl1cyk7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNlbnRlciBkb3RcbiAgICAgICAgICAgIGlmIChjZW50ZXJEb3RDb3VudGVyID49IDAgJiYgY2VudGVyRG90TmV4dFN0YXJ0VGltZSA8IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyRG90UmFkaXVzID0gY2VudGVyRG90RnVsbFJhZGl1cyAqIGNlbnRlckRvdENvdW50ZXI7XG4gICAgICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHgubW92ZVRvKG15LnBvc2l0aW9uWCArIGNlbnRlckRvdFJhZGl1cywgbXkucG9zaXRpb25ZKTtcbiAgICAgICAgICAgICAgICBtYWluRHluYW1pY0N0eC5hcmMobXkucG9zaXRpb25YLCBteS5wb3NpdGlvblksIGNlbnRlckRvdFJhZGl1cywgMCwgZG91YmxlUEksIHRydWUpO1xuICAgICAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjZW50ZXJEb3RDb3VudGVyIC09IC4xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCB0aGlzIHBhdHRlcm4ncyBlbGVtZW50cyBmcm9tIHRoZSBkeW5hbWljIGNvbnRleHQuXG4gICAgICAgICAqIFRoZXNlIGFyZSB0aGUgY2VudGVyIGRvdCwgbmVja2xhY2UgZG90cyBhbmQgcG9pbnRlci5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBtYWluRHluYW1pY0N0eCAyRCBjYW52YXMgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyRnJvbUR5bmFtaWNWaWV3ID0gZnVuY3Rpb24obWFpbkR5bmFtaWNDdHgpIHtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnNhdmUoKTtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnRyYW5zbGF0ZShteS5wb3NpdGlvblgsIG15LnBvc2l0aW9uWSk7XG4gICAgICAgICAgICBtYWluRHluYW1pY0N0eC5yb3RhdGUocG9pbnRlclJvdGF0aW9uUHJldmlvdXMpO1xuICAgICAgICAgICAgbWFpbkR5bmFtaWNDdHguY2xlYXJSZWN0KC1yYWRpdXMsIC1yYWRpdXMsIHJvdGF0ZUN0eC5jYW52YXMud2lkdGgsIHJvdGF0ZUN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1haW5EeW5hbWljQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGlmIGEgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdyYXBoaWMncyBoaXQgYXJlYS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB4IEhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB5IFZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBvaW50IGludGVyc2VjdHMuIFxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0c1dpdGhQb2ludCA9IGZ1bmN0aW9uKHgsIHksIGNhbnZhc1JlY3QpIHtcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gbXkucG9zaXRpb25YLCAyKSArIE1hdGgucG93KHkgLSBteS5wb3NpdGlvblksIDIpKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZSA8PSBjZW50ZXJSYWRpdXM7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0aGVtZSBjb2xvdXJzIG9mIHRoZSBwcm9jZXNzb3Igdmlldy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRoZW1lIFRoZW1lIHNldHRpbmdzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHNldFRoZW1lID0gZnVuY3Rpb24odGhlbWUpIHtcbiAgICAgICAgICAgIG15LmNvbG9ySGlnaCA9IHRoZW1lLmNvbG9ySGlnaDtcbiAgICAgICAgICAgIG15LmNvbG9yTWlkID0gdGhlbWUuY29sb3JNaWQ7XG4gICAgICAgICAgICBteS5jb2xvckxvdyA9IHRoZW1lLmNvbG9yTG93O1xuICAgICAgICAgICAgc3RhdGljQ3R4LnN0cm9rZVN0eWxlID0gbXkuY29sb3JIaWdoO1xuICAgICAgICAgICAgc3RhdGljQ3R4LmZpbGxTdHlsZSA9IG15LmNvbG9ySGlnaDtcbiAgICAgICAgICAgIHJvdGF0ZUN0eC5zdHJva2VTdHlsZSA9IG15LmNvbG9ySGlnaDtcbiAgICAgICAgICAgIHBvaW50ZXJDdHguc3Ryb2tlU3R5bGUgPSBteS5jb2xvckhpZ2g7XG4gICAgICAgICAgICBwb2ludGVyQ3R4LmZpbGxTdHlsZSA9IG15LmNvbG9ySGlnaDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdXBkYXRlTmFtZShteS5zdG9yZS5nZXRTdGF0ZSgpLnByb2Nlc3NvcnMuYnlJZFtteS5pZF0ucGFyYW1zLmJ5SWQpO1xuICAgICAgICAgICAgcmVkcmF3U3RhdGljQ2FudmFzKCk7XG4gICAgICAgICAgICByZWRyYXdSb3RhdGluZ0NhbnZhcygpO1xuICAgICAgICAgICAgcmVkcmF3UG9pbnRlckNhbnZhcygpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbXkgPSBteSB8fCB7fTtcbiAgICAgICAgXG4gICAgdGhhdCA9IGNyZWF0ZUNhbnZhc1Byb2Nlc3NvckJhc2VWaWV3KHNwZWNzLCBteSk7XG4gICAgXG4gICAgaW5pdGlhbGlzZSgpO1xuICAgIFxuICAgIHRoYXQudGVybWluYXRlID0gdGVybWluYXRlO1xuICAgIHRoYXQuc2V0U2VsZWN0ZWQgPSBzZXRTZWxlY3RlZDtcbiAgICB0aGF0LmRyYXcgPSBkcmF3O1xuICAgIHRoYXQuYWRkVG9TdGF0aWNWaWV3ID0gYWRkVG9TdGF0aWNWaWV3O1xuICAgIHRoYXQuYWRkVG9EeW5hbWljVmlldyA9IGFkZFRvRHluYW1pY1ZpZXc7XG4gICAgdGhhdC5jbGVhckZyb21EeW5hbWljVmlldyA9IGNsZWFyRnJvbUR5bmFtaWNWaWV3O1xuICAgIHRoYXQuaW50ZXJzZWN0c1dpdGhQb2ludCA9IGludGVyc2VjdHNXaXRoUG9pbnQ7XG4gICAgdGhhdC5zZXRUaGVtZSA9IHNldFRoZW1lO1xuICAgIHJldHVybiB0aGF0O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3doL3Byb2Nlc3NvcnMvZXVjbGlkZngvZ3JhcGhpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n");

/***/ }),

/***/ 41:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createGraphic = createGraphic;\n\nvar _canvasprocessorbase = __webpack_require__(35);\n\nvar _canvasprocessorbase2 = _interopRequireDefault(_canvasprocessorbase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * MIDI output object drawn on canvas.\n */\nfunction createGraphic(specs, my) {\n    var that = void 0,\n        canvasDirtyCallback = specs.canvasDirtyCallback,\n        staticCanvas = void 0,\n        staticCtx = void 0,\n        nameCanvas = void 0,\n        nameCtx = void 0,\n        isSelected = false,\n        lineWidth = 2,\n        width = 100,\n        height = 50,\n        radius = 10,\n        boxWidth = 80,\n        selectRadius = 15,\n        disconnectSize = 7,\n        doublePI = Math.PI * 2,\n        initialise = function initialise() {\n        document.addEventListener(my.store.STATE_CHANGE, handleStateChanges);\n        initGraphics();\n        setTheme(specs.theme);\n        updatePosition(specs.data.positionX, specs.data.positionY);\n        redrawStaticCanvas();\n    },\n\n\n    /**\n     * Called before this view is deleted.\n     */\n    terminate = function terminate() {\n        document.removeEventListener(my.store.STATE_CHANGE, handleStateChanges);\n        canvasDirtyCallback = null;\n    },\n        handleStateChanges = function handleStateChanges(e) {\n        var processor = e.detail.state.processors.byId[my.id];\n        switch (e.detail.action.type) {\n\n            case e.detail.actions.DRAG_SELECTED_PROCESSOR:\n            case e.detail.actions.DRAG_ALL_PROCESSORS:\n                updatePosition(processor.positionX, processor.positionY);\n                break;\n\n            case e.detail.actions.UPDATE_MIDI_PORT:\n                redrawStaticCanvas();\n                break;\n\n            case e.detail.actions.CHANGE_PARAMETER:\n                if (e.detail.action.processorID === my.id) {\n                    my.params = e.detail.state.processors.byId[my.id].params.byId;\n                    switch (e.detail.action.paramKey) {\n                        case 'port':\n                            redrawStaticCanvas();\n                            break;\n                        case 'name':\n                            updateName();\n                            break;\n                    }\n                }\n                break;\n        }\n    },\n        initGraphics = function initGraphics() {\n        // offscreen canvas for static shapes\n        staticCanvas = document.createElement('canvas');\n        staticCanvas.height = height;\n        staticCanvas.width = width;\n        staticCtx = staticCanvas.getContext('2d');\n        staticCtx.lineWidth = lineWidth;\n\n        // offscreen canvas for the name\n        nameCanvas = document.createElement('canvas');\n        nameCanvas.height = 40;\n        nameCanvas.width = 200;\n        nameCtx = nameCanvas.getContext('2d');\n        nameCtx.font = '14px sans-serif';\n        nameCtx.textAlign = 'center';\n    },\n        setSelected = function setSelected(isSelectedView, state) {\n        isSelected = isSelectedView;\n        if (typeof redrawStaticCanvas == 'function' && typeof canvasDirtyCallback == 'function') {\n            redrawStaticCanvas(state.processors.byId[my.id].enabled);\n            canvasDirtyCallback();\n        }\n    },\n        draw = function draw() {},\n\n\n    /**\n     * Redraw the graphic after a change.\n     */\n    redrawStaticCanvas = function redrawStaticCanvas() {\n        staticCtx.strokeStyle = my.colorHigh;\n\n        staticCtx.clearRect(0, 0, width, height);\n        staticCtx.save();\n        staticCtx.translate(width / 2, height / 2 - 8);\n        staticCtx.beginPath();\n\n        // box\n        staticCtx.rect(-boxWidth / 2, -radius, boxWidth, radius * 2);\n        // arrow\n        staticCtx.moveTo(-boxWidth / 2, radius);\n        staticCtx.lineTo(0, radius + 20);\n        staticCtx.lineTo(boxWidth / 2, radius);\n\n        // circle\n        staticCtx.moveTo(radius, 0);\n        staticCtx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\n        // disconnected cross\n        if (my.params.port.value === 'none') {\n            staticCtx.moveTo(-disconnectSize, -disconnectSize);\n            staticCtx.lineTo(disconnectSize, disconnectSize);\n            staticCtx.moveTo(disconnectSize, -disconnectSize);\n            staticCtx.lineTo(-disconnectSize, disconnectSize);\n        }\n\n        // select circle\n        if (isSelected) {\n            staticCtx.moveTo(selectRadius, 0);\n            staticCtx.arc(0, 0, selectRadius, 0, doublePI);\n        }\n\n        staticCtx.stroke();\n        staticCtx.restore();\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Update the pattern's name.\n     */\n    updateName = function updateName() {\n        nameCtx.fillStyle = my.colorMid;\n        nameCtx.clearRect(0, 0, nameCanvas.width, nameCanvas.height);\n        nameCtx.fillText(my.params.name.value, nameCanvas.width / 2, nameCanvas.height / 2);\n        canvasDirtyCallback();\n    },\n\n\n    /**\n     * Update pattern's position on the 2D canvas.\n     * @param  {Object} value New 2D position as object.\n     */\n    updatePosition = function updatePosition(x, y) {\n        my.positionX = x;\n        my.positionY = y;\n        canvasDirtyCallback();\n    },\n        addToStaticView = function addToStaticView(mainStaticCtx) {\n        mainStaticCtx.drawImage(staticCanvas, my.positionX - 50, my.positionY - 15);\n\n        mainStaticCtx.drawImage(nameCanvas, my.positionX - nameCanvas.width / 2, my.positionY + 30);\n    },\n        addToDynamicView = function addToDynamicView(mainDynamicCtx) {},\n\n\n    /**\n     * Clear all this pattern's elements from the dynamic context.\n     * These are the center dot, necklace dots and pointer.\n     * @param  {Object} mainDynamicCtx 2D canvas context.\n     */\n    clearFromDynamicView = function clearFromDynamicView(mainDynamicCtx) {},\n\n\n    /**\n     * Test if a coordinate intersects with the graphic's hit area.\n     * @param  {Number} x Horizontal coordinate.\n     * @param  {Number} y Vertical coordinate.\n     * @return {Boolean} True if the point intersects. \n     */\n    intersectsWithPoint = function intersectsWithPoint(x, y) {\n        var distance = Math.sqrt(Math.pow(x - my.positionX, 2) + Math.pow(y - my.positionY, 2));\n        return distance <= 10;\n    },\n\n\n    /**\n     * Set the theme colours of the processor view.\n     * @param {Object} theme Theme settings object.\n     */\n    setTheme = function setTheme(theme) {\n        my.colorHigh = theme.colorHigh;\n        my.colorMid = theme.colorMid;\n        my.colorLow = theme.colorLow;\n        redrawStaticCanvas();\n        updateName();\n    };\n\n    my = my || {};\n\n    that = (0, _canvasprocessorbase2.default)(specs, my);\n\n    initialise();\n\n    that.terminate = terminate;\n    that.setSelected = setSelected;\n    that.draw = draw;\n    that.addToStaticView = addToStaticView;\n    that.addToDynamicView = addToDynamicView;\n    that.clearFromDynamicView = clearFromDynamicView;\n    that.intersectsWithPoint = intersectsWithPoint;\n    that.setTheme = setTheme;\n    return that;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9vdXRwdXQvZ3JhcGhpYy5qcz84NzI2Il0sIm5hbWVzIjpbImNyZWF0ZUdyYXBoaWMiLCJzcGVjcyIsIm15IiwidGhhdCIsImNhbnZhc0RpcnR5Q2FsbGJhY2siLCJzdGF0aWNDYW52YXMiLCJzdGF0aWNDdHgiLCJuYW1lQ2FudmFzIiwibmFtZUN0eCIsImlzU2VsZWN0ZWQiLCJsaW5lV2lkdGgiLCJ3aWR0aCIsImhlaWdodCIsInJhZGl1cyIsImJveFdpZHRoIiwic2VsZWN0UmFkaXVzIiwiZGlzY29ubmVjdFNpemUiLCJkb3VibGVQSSIsIk1hdGgiLCJQSSIsImluaXRpYWxpc2UiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdG9yZSIsIlNUQVRFX0NIQU5HRSIsImhhbmRsZVN0YXRlQ2hhbmdlcyIsImluaXRHcmFwaGljcyIsInNldFRoZW1lIiwidGhlbWUiLCJ1cGRhdGVQb3NpdGlvbiIsImRhdGEiLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJyZWRyYXdTdGF0aWNDYW52YXMiLCJ0ZXJtaW5hdGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZSIsInByb2Nlc3NvciIsImRldGFpbCIsInN0YXRlIiwicHJvY2Vzc29ycyIsImJ5SWQiLCJpZCIsImFjdGlvbiIsInR5cGUiLCJhY3Rpb25zIiwiRFJBR19TRUxFQ1RFRF9QUk9DRVNTT1IiLCJEUkFHX0FMTF9QUk9DRVNTT1JTIiwiVVBEQVRFX01JRElfUE9SVCIsIkNIQU5HRV9QQVJBTUVURVIiLCJwcm9jZXNzb3JJRCIsInBhcmFtcyIsInBhcmFtS2V5IiwidXBkYXRlTmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0IiwiZm9udCIsInRleHRBbGlnbiIsInNldFNlbGVjdGVkIiwiaXNTZWxlY3RlZFZpZXciLCJlbmFibGVkIiwiZHJhdyIsInN0cm9rZVN0eWxlIiwiY29sb3JIaWdoIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInRyYW5zbGF0ZSIsImJlZ2luUGF0aCIsInJlY3QiLCJtb3ZlVG8iLCJsaW5lVG8iLCJhcmMiLCJwb3J0IiwidmFsdWUiLCJzdHJva2UiLCJyZXN0b3JlIiwiZmlsbFN0eWxlIiwiY29sb3JNaWQiLCJmaWxsVGV4dCIsIm5hbWUiLCJ4IiwieSIsImFkZFRvU3RhdGljVmlldyIsIm1haW5TdGF0aWNDdHgiLCJkcmF3SW1hZ2UiLCJhZGRUb0R5bmFtaWNWaWV3IiwibWFpbkR5bmFtaWNDdHgiLCJjbGVhckZyb21EeW5hbWljVmlldyIsImludGVyc2VjdHNXaXRoUG9pbnQiLCJkaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJjb2xvckxvdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFLZ0JBLGEsR0FBQUEsYTs7QUFMaEI7Ozs7OztBQUVBOzs7QUFHTyxTQUFTQSxhQUFULENBQXVCQyxLQUF2QixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDckMsUUFBSUMsYUFBSjtBQUFBLFFBQ0lDLHNCQUFzQkgsTUFBTUcsbUJBRGhDO0FBQUEsUUFFSUMscUJBRko7QUFBQSxRQUdJQyxrQkFISjtBQUFBLFFBSUlDLG1CQUpKO0FBQUEsUUFLSUMsZ0JBTEo7QUFBQSxRQU9JQyxhQUFhLEtBUGpCO0FBQUEsUUFTSUMsWUFBWSxDQVRoQjtBQUFBLFFBVUlDLFFBQVEsR0FWWjtBQUFBLFFBV0lDLFNBQVMsRUFYYjtBQUFBLFFBWUlDLFNBQVMsRUFaYjtBQUFBLFFBYUlDLFdBQVcsRUFiZjtBQUFBLFFBY0lDLGVBQWUsRUFkbkI7QUFBQSxRQWVJQyxpQkFBaUIsQ0FmckI7QUFBQSxRQWdCSUMsV0FBV0MsS0FBS0MsRUFBTCxHQUFVLENBaEJ6QjtBQUFBLFFBa0JJQyxhQUFhLFNBQWJBLFVBQWEsR0FBVztBQUNwQkMsaUJBQVNDLGdCQUFULENBQTBCcEIsR0FBR3FCLEtBQUgsQ0FBU0MsWUFBbkMsRUFBaURDLGtCQUFqRDtBQUNBQztBQUNBQyxpQkFBUzFCLE1BQU0yQixLQUFmO0FBQ0FDLHVCQUFlNUIsTUFBTTZCLElBQU4sQ0FBV0MsU0FB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U0FBS3dCLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsV0FBT3hCLElBQVA7QUFDSCIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVDYW52YXNQcm9jZXNzb3JCYXNlVmlldyBmcm9tICcuLi8uLi92aWV3L2NhbnZhc3Byb2Nlc3NvcmJhc2UuanMnO1xuXG4vKipcbiAqIE1JREkgb3V0cHV0IG9iamVjdCBkcmF3biBvbiBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHcmFwaGljKHNwZWNzLCBteSkge1xuICAgIGxldCB0aGF0LFxuICAgICAgICBjYW52YXNEaXJ0eUNhbGxiYWNrID0gc3BlY3MuY2FudmFzRGlydHlDYWxsYmFjayxcbiAgICAgICAgc3RhdGljQ2FudmFzLFxuICAgICAgICBzdGF0aWNDdHgsXG4gICAgICAgIG5hbWVDYW52YXMsXG4gICAgICAgIG5hbWVDdHgsXG5cbiAgICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlLFxuXG4gICAgICAgIGxpbmVXaWR0aCA9IDIsXG4gICAgICAgIHdpZHRoID0gMTAwLFxuICAgICAgICBoZWlnaHQgPSA1MCxcbiAgICAgICAgcmFkaXVzID0gMTAsXG4gICAgICAgIGJveFdpZHRoID0gODAsXG4gICAgICAgIHNlbGVjdFJhZGl1cyA9IDE1LFxuICAgICAgICBkaXNjb25uZWN0U2l6ZSA9IDcsXG4gICAgICAgIGRvdWJsZVBJID0gTWF0aC5QSSAqIDIsXG4gICAgICAgIFxuICAgICAgICBpbml0aWFsaXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG15LnN0b3JlLlNUQVRFX0NIQU5HRSwgaGFuZGxlU3RhdGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIGluaXRHcmFwaGljcygpO1xuICAgICAgICAgICAgc2V0VGhlbWUoc3BlY3MudGhlbWUpO1xuICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24oc3BlY3MuZGF0YS5wb3NpdGlvblgsIHNwZWNzLmRhdGEucG9zaXRpb25ZKTtcbiAgICAgICAgICAgIHJlZHJhd1N0YXRpY0NhbnZhcygpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBiZWZvcmUgdGhpcyB2aWV3IGlzIGRlbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXJtaW5hdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobXkuc3RvcmUuU1RBVEVfQ0hBTkdFLCBoYW5kbGVTdGF0ZUNoYW5nZXMpO1xuICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlU3RhdGVDaGFuZ2VzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gZS5kZXRhaWwuc3RhdGUucHJvY2Vzc29ycy5ieUlkW215LmlkXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5kZXRhaWwuYWN0aW9uLnR5cGUpIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgZS5kZXRhaWwuYWN0aW9ucy5EUkFHX1NFTEVDVEVEX1BST0NFU1NPUjpcbiAgICAgICAgICAgICAgICBjYXNlIGUuZGV0YWlsLmFjdGlvbnMuRFJBR19BTExfUFJPQ0VTU09SUzpcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24ocHJvY2Vzc29yLnBvc2l0aW9uWCwgcHJvY2Vzc29yLnBvc2l0aW9uWSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBlLmRldGFpbC5hY3Rpb25zLlVQREFURV9NSURJX1BPUlQ6XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd1N0YXRpY0NhbnZhcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYXNlIGUuZGV0YWlsLmFjdGlvbnMuQ0hBTkdFX1BBUkFNRVRFUjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGV0YWlsLmFjdGlvbi5wcm9jZXNzb3JJRCA9PT0gbXkuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15LnBhcmFtcyA9IGUuZGV0YWlsLnN0YXRlLnByb2Nlc3NvcnMuYnlJZFtteS5pZF0ucGFyYW1zLmJ5SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUuZGV0YWlsLmFjdGlvbi5wYXJhbUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRyYXdTdGF0aWNDYW52YXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdEdyYXBoaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvZmZzY3JlZW4gY2FudmFzIGZvciBzdGF0aWMgc2hhcGVzXG4gICAgICAgICAgICBzdGF0aWNDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHN0YXRpY0NhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBzdGF0aWNDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHN0YXRpY0N0eCA9IHN0YXRpY0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgc3RhdGljQ3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgLy8gb2Zmc2NyZWVuIGNhbnZhcyBmb3IgdGhlIG5hbWVcbiAgICAgICAgICAgIG5hbWVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIG5hbWVDYW52YXMuaGVpZ2h0ID0gNDA7XG4gICAgICAgICAgICBuYW1lQ2FudmFzLndpZHRoID0gMjAwO1xuICAgICAgICAgICAgbmFtZUN0eCA9IG5hbWVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIG5hbWVDdHguZm9udCA9ICcxNHB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgbmFtZUN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTZWxlY3RlZCA9IGZ1bmN0aW9uKGlzU2VsZWN0ZWRWaWV3LCBzdGF0ZSkge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWRWaWV3O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWRyYXdTdGF0aWNDYW52YXMgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2FudmFzRGlydHlDYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVkcmF3U3RhdGljQ2FudmFzKHN0YXRlLnByb2Nlc3NvcnMuYnlJZFtteS5pZF0uZW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgY2FudmFzRGlydHlDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRyYXcgPSBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWRyYXcgdGhlIGdyYXBoaWMgYWZ0ZXIgYSBjaGFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICByZWRyYXdTdGF0aWNDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0YXRpY0N0eC5zdHJva2VTdHlsZSA9IG15LmNvbG9ySGlnaDtcblxuICAgICAgICAgICAgc3RhdGljQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHN0YXRpY0N0eC5zYXZlKCk7XG4gICAgICAgICAgICBzdGF0aWNDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiAtIDgpO1xuICAgICAgICAgICAgc3RhdGljQ3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICAvLyBib3hcbiAgICAgICAgICAgIHN0YXRpY0N0eC5yZWN0KC1ib3hXaWR0aCAvIDIsIC1yYWRpdXMsIGJveFdpZHRoLCByYWRpdXMgKiAyKTtcbiAgICAgICAgICAgIC8vIGFycm93XG4gICAgICAgICAgICBzdGF0aWNDdHgubW92ZVRvKC1ib3hXaWR0aCAvIDIsIHJhZGl1cyk7XG4gICAgICAgICAgICBzdGF0aWNDdHgubGluZVRvKDAsIHJhZGl1cyArIDIwKVxuICAgICAgICAgICAgc3RhdGljQ3R4LmxpbmVUbyhib3hXaWR0aCAvIDIsIHJhZGl1cyk7XG5cbiAgICAgICAgICAgIC8vIGNpcmNsZVxuICAgICAgICAgICAgc3RhdGljQ3R4Lm1vdmVUbyhyYWRpdXMsIDApO1xuICAgICAgICAgICAgc3RhdGljQ3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gZGlzY29ubmVjdGVkIGNyb3NzXG4gICAgICAgICAgICBpZiAobXkucGFyYW1zLnBvcnQudmFsdWUgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHN0YXRpY0N0eC5tb3ZlVG8oLWRpc2Nvbm5lY3RTaXplLCAtZGlzY29ubmVjdFNpemUpO1xuICAgICAgICAgICAgICAgIHN0YXRpY0N0eC5saW5lVG8oZGlzY29ubmVjdFNpemUsIGRpc2Nvbm5lY3RTaXplKTtcbiAgICAgICAgICAgICAgICBzdGF0aWNDdHgubW92ZVRvKGRpc2Nvbm5lY3RTaXplLCAtZGlzY29ubmVjdFNpemUpO1xuICAgICAgICAgICAgICAgIHN0YXRpY0N0eC5saW5lVG8oLWRpc2Nvbm5lY3RTaXplLCBkaXNjb25uZWN0U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlbGVjdCBjaXJjbGVcbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ3R4Lm1vdmVUbyhzZWxlY3RSYWRpdXMsIDApO1xuICAgICAgICAgICAgICAgIHN0YXRpY0N0eC5hcmMoMCwgMCwgc2VsZWN0UmFkaXVzLCAwLCBkb3VibGVQSSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRpY0N0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHN0YXRpY0N0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBjYW52YXNEaXJ0eUNhbGxiYWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBwYXR0ZXJuJ3MgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5hbWVDdHguZmlsbFN0eWxlID0gbXkuY29sb3JNaWQ7XG4gICAgICAgICAgICBuYW1lQ3R4LmNsZWFyUmVjdCgwLCAwLCBuYW1lQ2FudmFzLndpZHRoLCBuYW1lQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBuYW1lQ3R4LmZpbGxUZXh0KG15LnBhcmFtcy5uYW1lLnZhbHVlLCBuYW1lQ2FudmFzLndpZHRoIC8gMiwgbmFtZUNhbnZhcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGNhbnZhc0RpcnR5Q2FsbGJhY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgcGF0dGVybidzIHBvc2l0aW9uIG9uIHRoZSAyRCBjYW52YXMuXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gdmFsdWUgTmV3IDJEIHBvc2l0aW9uIGFzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgbXkucG9zaXRpb25YID0geDtcbiAgICAgICAgICAgIG15LnBvc2l0aW9uWSA9IHk7XG4gICAgICAgICAgICBjYW52YXNEaXJ0eUNhbGxiYWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBhZGRUb1N0YXRpY1ZpZXcgPSBmdW5jdGlvbihtYWluU3RhdGljQ3R4KSB7XG4gICAgICAgICAgICBtYWluU3RhdGljQ3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBzdGF0aWNDYW52YXMsXG4gICAgICAgICAgICAgICAgbXkucG9zaXRpb25YIC0gNTAsXG4gICAgICAgICAgICAgICAgbXkucG9zaXRpb25ZIC0gMTUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgbWFpblN0YXRpY0N0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgbmFtZUNhbnZhcyxcbiAgICAgICAgICAgICAgICBteS5wb3NpdGlvblggLSAobmFtZUNhbnZhcy53aWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgIG15LnBvc2l0aW9uWSArIDMwKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGFkZFRvRHluYW1pY1ZpZXcgPSBmdW5jdGlvbihtYWluRHluYW1pY0N0eCkge1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCB0aGlzIHBhdHRlcm4ncyBlbGVtZW50cyBmcm9tIHRoZSBkeW5hbWljIGNvbnRleHQuXG4gICAgICAgICAqIFRoZXNlIGFyZSB0aGUgY2VudGVyIGRvdCwgbmVja2xhY2UgZG90cyBhbmQgcG9pbnRlci5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBtYWluRHluYW1pY0N0eCAyRCBjYW52YXMgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyRnJvbUR5bmFtaWNWaWV3ID0gZnVuY3Rpb24obWFpbkR5bmFtaWNDdHgpIHtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGlmIGEgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdyYXBoaWMncyBoaXQgYXJlYS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB4IEhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB5IFZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBvaW50IGludGVyc2VjdHMuIFxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0c1dpdGhQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gbXkucG9zaXRpb25YLCAyKSArIE1hdGgucG93KHkgLSBteS5wb3NpdGlvblksIDIpKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZSA8PSAxMDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRoZW1lIGNvbG91cnMgb2YgdGhlIHByb2Nlc3NvciB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhlbWUgVGhlbWUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGhlbWUgPSBmdW5jdGlvbih0aGVtZSkge1xuICAgICAgICAgICAgbXkuY29sb3JIaWdoID0gdGhlbWUuY29sb3JIaWdoO1xuICAgICAgICAgICAgbXkuY29sb3JNaWQgPSB0aGVtZS5jb2xvck1pZDtcbiAgICAgICAgICAgIG15LmNvbG9yTG93ID0gdGhlbWUuY29sb3JMb3c7XG4gICAgICAgICAgICByZWRyYXdTdGF0aWNDYW52YXMoKTtcbiAgICAgICAgICAgIHVwZGF0ZU5hbWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgbXkgPSBteSB8fCB7fTtcbiAgICBcbiAgICB0aGF0ID0gY3JlYXRlQ2FudmFzUHJvY2Vzc29yQmFzZVZpZXcoc3BlY3MsIG15KTtcbiAgICBcbiAgICBpbml0aWFsaXNlKCk7XG4gICAgXG4gICAgdGhhdC50ZXJtaW5hdGUgPSB0ZXJtaW5hdGU7XG4gICAgdGhhdC5zZXRTZWxlY3RlZCA9IHNldFNlbGVjdGVkO1xuICAgIHRoYXQuZHJhdyA9IGRyYXc7XG4gICAgdGhhdC5hZGRUb1N0YXRpY1ZpZXcgPSBhZGRUb1N0YXRpY1ZpZXc7XG4gICAgdGhhdC5hZGRUb0R5bmFtaWNWaWV3ID0gYWRkVG9EeW5hbWljVmlldztcbiAgICB0aGF0LmNsZWFyRnJvbUR5bmFtaWNWaWV3ID0gY2xlYXJGcm9tRHluYW1pY1ZpZXc7XG4gICAgdGhhdC5pbnRlcnNlY3RzV2l0aFBvaW50ID0gaW50ZXJzZWN0c1dpdGhQb2ludDtcbiAgICB0aGF0LnNldFRoZW1lID0gc2V0VGhlbWU7XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvd2gvcHJvY2Vzc29ycy9vdXRwdXQvZ3JhcGhpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n");

/***/ })

});